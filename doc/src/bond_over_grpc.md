% Bond-over-gRPC

# About #

Bond-over-gRPC provides code generation from Bond IDL service definitions
to send Bond objects via [gRPC](http://www.grpc.io/) The gRPC functionality
supercedes the (now deprecated) Bond Comm framework.

# Features #

## Defining Services ##

The Bond IDL has been extended to support the definition of
[services](compiler.html#service-definition) and
[generic services](compiler.html#generic-service). These definitions are
used by the Bond compiler to generate classes that provide:

* a service base that can be used as the basis for implementing services'
  methods
* a proxy stub that can be used by clients to invoke those methods

To generate these classes, pass the `--grpc` flag to `gbc` (the Bond compiler
tool).

Note that gRPC doesn't provide a messaging pattern that matches
the semantics of methods with a return type of `nothing`; to compensate,
`gbc` provides generated wrappers to simulate the appropriate semantics.

Also note that Bond-over-gRPC does not yet provide interfaces for gRPC's
streaming; this functionality will be added in the coming months.

# Implementations #

Bond-over-gRPC is available for C# and C++.

## Bond-over-gRPC for C# ##

Given a service definition like the following:

```
service Example
{
    ExampleResponse ExampleMethod(ExampleRequest);
}
```

`gbc` will generate C# classes for gRPC with the `--grpc` flag:

```
gbc c# --grpc example.bond
```

The key generated C# classes for gRPC are:

* A simple class with the name of the service (e.g.: `Example`). This class
  provides some basic encapsulation of the server-side service base, the
  client-side proxy stub, and some static methods and data members for
  initialization.
* The service base, which is named with the name of the service plus the suffix
  `Base` (e.g.: `Example.ExampleBase`). This class has abstract methods
  for each of the methods defined in the service IDL, serving as a base for the
  concrete implementation which will provide the actual server-side business
  logic.
* The proxy stub, which is named with the name of the service plus the suffix
  `Client' (e.g.: `Example.ExampleClient`). This is used to invoke the service
  from the client side.

To build the service functionality, simply write a concrete service
implementation by subclassing the server base and supplying the business logic:

```csharp
public class ExampleServiceImpl : Example.ExampleBase
{
    public override async Task<IMessage<ExampleResponse>> ExampleMethod(IMessage<ExampleRequest> param, ServerCallContext context)
    {
        ExampleRequest request = param.Payload.Deserialize();
        var response = new ExampleResponse();

        // Service business logic goes here

        return Message.From(response);
    }
}
```

This service implementation is hooked up to a gRPC server as follows:

```csharp
var server = new Grpc.Core.Server
{
    Services = { Example.BindService(new ExampleServiceImpl()) },
    Ports = { new Grpc.Core.ServerPort(ExampleHost, ExamplePort, Grpc.Core.ServerCredentials.Insecure) }
};
server.Start();
```

At this point the server is ready to receive requests and route them to the
service implementation.

On the client side, the proxy stub establishes a connection to the server like this:

```csharp
var channel = new Grpc.Core.Channel(ExampleHost, ExamplePort, Grpc.Core.ChannelCredentials.Insecure);
var client = new Example.ExampleClient(channel);
```

The proxy stub can then be used to make calls to the server as follows:

```csharp
var request = new ExampleRequest();
// Fill in request fields here

IMessage<ExampleResponse> responseMessage = await client.Method(request);

ExampleResponse response = responseMessage.Payload.Deserialize().Payload;
// Examine response here
```

Note that the signatures generated by `gbc` are slightly different from the
ones in the gRPC documentation: on the service side, the request is wrapped in
`IMessage<T>` and on the client side, the response is wrapped in
`IMessage<T>; this allows for better control over the time of
deserialization and also helps prevent slicing when using polymorphic Bond
types. Note also that Bond-over-gRPC does not provide synchronous APIs in C#
by design.

For more information about gRPC in C#, take a look at the
[gRPC C# tutorial](http://www.grpc.io/docs/tutorials/basic/csharp.html).

There is a [Bond-over-gRPC standalone example project](https://github.com/Microsoft/bond-grpc-examples).

See also the following example:

- `examples/cs/grpc/pingpong`

## Bond-over-gRPC for C++ ##

Given a service definition like the following:

```
service Example
{
    ExampleResponse ExampleMethod(ExampleRequest);
}
```

`gbc` will generate C++ classes for gRPC with the `--grpc` flag:

```
gbc c++ --grpc example.bond
```

The key generated C++ classes for gRPC are:

* A simple class with the name of the service (e.g.: `Example`). This class
  provides some basic encapsulation of the server-side service base and the
  client-side proxy stub.
* The service base, which is an inner class named `Service` (e.g.:
  `Example::Service`). This class has abstract methods
  for each of the methods defined in the service IDL, serving as a base for the
  concrete implementation which will provide the actual server-side business
  logic. (Technically, `Service` is a type alias for
  `ServiceCore<bond::ext::gRPC::thread_pool>`. The `ServiceCore<T>` template
  can be used to customize the service implementation to use a different
  thread pool implementation.)
* The proxy stub, which is an inner class named `Client` (e.g.:
  `Example::Client`). This is used to invoke the service from the
  client side. (Likewise, `Client` is a type alias for
  `ClientCore<bond::ext::gRPC::thread_pool>`. The `ClientCore<T>` template
  can be used to customize the client implementation to use a different
  thread pool implementation.)  

To build the service functionality, simply write a concrete service
implementation by subclassing the server base and supplying the business logic:

```cpp
class ExampleServiceImpl final : Example::Service
{
    void ExampleMethod(
        bond::ext::gRPC::unary_call<
            bond::bonded<ExampleRequest>,
            ExampleResponse> call) override
    {
        ExampleRequest request = call.request().Deserialize();
        ExampleResponse response;

        // Service business logic goes here

        call.Finish(response);
    }
}
```

This service implementation is hooked up to a gRPC server as follows:

```cpp
auto ioManager = std::make_shared<bond::ext::gRPC::io_manager>();
auto threadPool = std::make_shared<bond::ext::gRPC::thread_pool>();
const std::string server_address(Host + ":" + Port);

ExampleServiceImpl service;
bond::ext::gRPC::server_builder builder;
builder.SetThreadPool(threadPool);
builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
builder.RegisterService(&service);
std::unique_ptr<bond::ext::gRPC::server> server(builder.BuildAndStart());
```

At this point the server is ready to receive requests and route them to the
service implementation.

On the client side, the proxy stub establishes a connection to the server like this:

```cpp
auto ioManager = std::make_shared<bond::ext::gRPC::io_manager>();
auto threadPool = std::make_shared<bond::ext::gRPC::thread_pool>();
const std::string server_address(Host + ":" + Port);

Example::Client client(
    grpc::CreateChannel(server_address, grpc::InsecureChannelCredentials()),
    ioManager,
    threadPool);
```

The proxy stub can then be used to make calls to the server as follows:

```cpp
ExampleRequest request;
// Fill in request fields here

bond::ext::gRPC::wait_callback<ExampleResponse> cb;
client.AsyncExampleMethod(request, callback);

callback.wait();
ExampleResponse response = callback.response().Deserialize();
// Examine response here
```

Note these APIs are significantly different from the APIs presented in the
gRPC documentation; Bond-over-gRPC is attempting to provide a more
straightforward API for asynchronous communication than gRPC currently
presents in C++. Bond-over-gRPC does not provide synchronous APIs in C++ by
design. The use of [`wait_callback<T>`][wait_callback_reference] here is for
illustrative purposes; any callback implementation with the same signature
can be used. `wait_callback` satisfies the signature and provides a `wait()`
method to adapt the asynchronous proxy method into an effectively
synchronous call.

The proxy stub has a number of overloads for each method. The simplest is
demonstrated above, and there are ones that take `bonded<T>` and
`grpc::ClientContext` arguments.

Using `bonded<T>` to wrap the request and response objects allows for better
control over the time of deserialization and also helps prevent slicing when
using polymorphic Bond types. As demonstrated above, convenience APIs are
provided in some places to hide the use `bonded<T>` where possible. For use
of `bonded` request objects and `ClientContext` arguments, see the pingpong
example.

For more information about gRPC in C++, take a look at the
[gRPC C++ tutorial](http://www.grpc.io/docs/tutorials/basic/c.html);
however, keep in mind that the Bond-over-gRPC APIs diverge significantly
from those documented there.

See also the following example:

- `examples/cpp/grpc/helloworld`
- `examples/cpp/grpc/pingpong`

[wait_callback_reference]: ../reference/cpp/classbond_1_1ext_1_1g_r_p_c_1_1wait__callback.html
