<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Bond compiler</title>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  body {
      line-height: 1.5;
      font-family: Helvetica, Arial, sans-serif;
      color: #333333;
      font-size: 1em;
  }
  code {
      font-size: 1em;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace, serif;
  }
  td.lineNumbers { width: 40px; }
  div#all {
    max-width: 1120px;
    background-color: #ffffff;
    margin: 0 auto;
    padding: 25px;
    overflow: auto;
  }
  code > span.kw { color: #204a87; font-weight: normal; } /* Keyword */
  code > span.co { color: #4E9A06; font-style: normal; }
  code > span.st { color: #8A0303; font-style: normal; }
  code > span.cf { color: #204a87; font-weight: normal; } /* ControlFlow */
  code > span.op { color: #000000; font-weight: normal; } /* Operator */
  code > span.pp { color: #8f5902; font-style: normal; } /* Preprocessor */
  code > span.ex { } /* Extension */
  code > span.at { color: #c4a000; } /* Attribute */
  code > span.do { color: #8f5902; font-weight: normal; font-style: normal; } /* Documentation */
  code > span.an { color: #8f5902; font-weight: normal; font-style: normal; } /* Annotation */
  code > span.cv { color: #8f5902; font-weight: normal; font-style: normal; } /* CommentVar */
  code > span.in { color: #8f5902; font-weight: normal; font-style: normal; } /* Information */

  h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    border-bottom: 1px solid black;
  }

  div.sourceCode {
    overflow-x: auto;
    max-height: 620px;
  }

  table.sourceCode {
    line-height: 120%;
  }

  #toc {
    width: 300px;
    position:fixed;
    overflow: auto;
    height: 95%;
  }

  #main {
    margin-left: 320px;
    margin-rigth: auto;
    max-width: 800px;
  }
  a {
    text-decoration: none;
  }
  #toc a:visited {
    color: #99c;
  }
  #main a:visited {
    color: #36c;
  }
  a:link {
    color: #36c;
  }
  @media screen and (max-width: 979px){
  #main {
    margin-left: auto;
    margin-right: auto;
  }
  #toc {
    left: -300px;
  }
  }
  </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58775439-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav id="TOC"></nav>
<div id="all">
<div id="toc">
<p><img src="data:image/png;base64,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" alt="The Bond logo: a stylized glue gun" /></p>
<ul>
<li><a href="#command-line-options">Command line options</a></li>
<li><a href="#idl-syntax">IDL syntax</a><ul>
<li><a href="#import-statements">Import statements</a></li>
<li><a href="#namespace-definition">Namespace definition</a></li>
<li><a href="#enum-definition">Enum definition</a></li>
<li><a href="#forward-declaration">Forward declaration</a></li>
<li><a href="#struct-definition">Struct definition</a></li>
<li><a href="#generic-struct">Generic struct</a></li>
<li><a href="#type-aliases">Type aliases</a></li>
<li><a href="#struct-views">Struct views</a></li>
<li><a href="#service-definition">Service definition</a></li>
<li><a href="#generic-service">Generic service</a></li>
<li><a href="#custom-attributes">Custom attributes</a></li>
<li><a href="#comments">Comments</a></li>
</ul></li>
<li><a href="#schema-ast">Schema AST</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#bond">Bond</a></li>
<li><a href="#import">Import</a></li>
<li><a href="#namespace">Namespace</a></li>
<li><a href="#declaration">Declaration</a><ul>
<li><a href="#struct">Struct</a></li>
<li><a href="#service">Service</a></li>
<li><a href="#enum">Enum</a></li>
<li><a href="#type-alias">Type alias</a></li>
<li><a href="#forward-declaration-1">Forward declaration</a></li>
<li><a href="#service-1">Service</a></li>
</ul></li>
<li><a href="#qualified-name">Qualified name</a></li>
<li><a href="#type-parameter">Type parameter</a></li>
<li><a href="#attribute">Attribute</a></li>
<li><a href="#struct-field">Struct field</a><ul>
<li><a href="#field-default-value">Field default value</a></li>
</ul></li>
<li><a href="#type">Type</a><ul>
<li><a href="#basic-types">Basic types</a></li>
<li><a href="#complex-types">Complex types</a></li>
</ul></li>
<li><a href="#service-method">Service method</a><ul>
<li><a href="#message">Message</a></li>
<li><a href="#service-type">Service type</a></li>
</ul></li>
</ul></li>
<li><a href="#runtime-schema">Runtime Schema</a><ul>
<li><a href="#example-1">Example</a></li>
</ul></li>
<li><a href="#library">Library</a></li>
</ul>
</div>
<div id="main">
<div id="header">
<h1 class="title">Bond compiler</h1>
</div>
<h1 id="command-line-options">Command line options</h1>
<div class="sourceCode">
<object width="100%" height="600" data="gbc.html"></object>
</div>
<h1 id="idl-syntax">IDL syntax</h1>
<p>A Bond schema definition file can contain the following elements:</p>
<ul>
<li>Import statements</li>
<li>Namespace definition</li>
<li>Declarations
<ul>
<li>enum</li>
<li>forward declaration</li>
<li>struct</li>
<li>generic structs</li>
<li>type aliases</li>
<li>services</li>
<li>generic services</li>
<li>struct view</li>
</ul></li>
<li>Custom attributes</li>
<li>Comments</li>
</ul>
<h2 id="import-statements">Import statements</h2>
<p>In order to use types defined in another schema definition file, the other file needs to be explicitly imported. Schema file can contain zero or more import statements and they must appear at the top of the file:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">import <span class="st">&quot;file.bond&quot;</span></code></pre></div>
<p>The file being imported can be specified using a partial path which is resolved by Bond compiler relative to the directory containing the schema file being compiled and any import path(s) specified using the –import-dir option(s) passed to gbc.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/import</code></li>
<li><code>examples/cs/core/import</code></li>
</ul>
<h2 id="namespace-definition">Namespace definition</h2>
<p>All schema types are always defined within a namespace. Namespace scope starts with namespace definition statement and ends at the end of the file.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> some.unique.name</code></pre></div>
<h2 id="enum-definition">Enum definition</h2>
<p>Bond enums are very similar to C++ enums, both in semantics and syntax used to define them:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> Protocols
{
    TCP,
    UDP = <span class="dv">10</span>
}</code></pre></div>
<p>On the wire values of enums types are equivalent to 32-bit signed integers.</p>
<h2 id="forward-declaration">Forward declaration</h2>
<p>In order to define recursive schemas, such as trees, it may be necessary to declare a struct before it is defined. A forward declaration statement serves this purpose:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node;</code></pre></div>
<p>Forward declared structs can be used in field declarations as the base type for nullable&lt;T&gt; and bonded&lt;T&gt; or the element type of a container.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node;

<span class="kw">struct</span> Node
{
    <span class="dv">0</span>: nullable&lt;Node&gt; left;
    <span class="dv">1</span>: nullable&lt;Node&gt; right;
}</code></pre></div>
<h2 id="struct-definition">Struct definition</h2>
<p>Struct definition consists of a struct name, an optional base struct, and zero or more fields.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example : Base
{
    <span class="dv">0</span>: uint32 fieldName = <span class="dv">10</span>;
}</code></pre></div>
<p>Field definition consists of an ordinal, type, name and optional default value. Field type can be:</p>
<ul>
<li><p>Basic type: <code>bool</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>float</code>, <code>double</code>, <code>string</code>, <code>wstring</code>.</p></li>
<li><p>Container: <code>blob</code>, <code>list&lt;T&gt;</code>, <code>vector&lt;T&gt;</code>, <code>set&lt;T&gt;</code>, <code>map&lt;K, T&gt;</code>, <code>nullable&lt;T&gt;</code>.</p></li>
<li><p>User-defined type: enum, struct or <code>bonded&lt;T&gt;</code> where T is a struct.</p></li>
</ul>
<p>An optional default value can be specified for fields of basic types. For integers the default can be specified as either a decimal number or a hexadecimal number prefixed with <code>0x</code>. The only explicit default value allowed for containers is <a href="#default-value-of-nothing"><code>nothing</code></a>. Enum fields must have an explicit default value which must be one of the enum named constants or <a href="#default-value-of-nothing"><code>nothing</code></a>.</p>
<p>Names of structs and enums defined in another namespace must be qualified with the namespace name:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">import <span class="st">&quot;bond/core/bond.bond&quot;</span>

<span class="kw">namespace</span> example

<span class="kw">struct</span> Example
{
    <span class="dv">0</span>: bond.GUID id;
    <span class="dv">1</span>: bond.BondDataType type = BT_UNAVAILABLE;
}</code></pre></div>
<h2 id="generic-struct">Generic struct</h2>
<p>Generic structs are parameterized with one or more type parameters which can be used within the struct definition in any place where a concrete type could be used (e.g. base struct, field type, container element type, parameter of a generic struct).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example&lt;T1, T2&gt; : T<span class="dv">1</span>
{
    <span class="dv">0</span>: T1 field;
    <span class="dv">1</span>: list&lt;T2&gt; list;
    <span class="dv">2</span>: Generic&lt;T2&gt; generic;
}</code></pre></div>
<p>The usage of a type parameter within a generic struct definition may implicitly constrain what type(s) can be used to instantiate the generic struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example&lt;T&gt;
{
    <span class="co">// The default value of 10 implicitly constrains T to numeric types</span>
    <span class="dv">0</span>: T x = <span class="dv">10</span>;
}</code></pre></div>
<p>Using a type parameter in a <a href="#nullable-types"><code>nullable</code></a> or as the type of a field with default value of <a href="#default-value-of-nothing"><code>nothing</code></a> constrains the type parameter to be non-scalar type. If this is undesired then explicit constraint to value type can be specified in the generic schema definition:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example&lt;T : value&gt;
{
    <span class="dv">0</span>: nullable&lt;T&gt; x;
    <span class="dv">1</span>: T y = nothing;
}</code></pre></div>
<p>When instantiating a generic struct all type parameters must be concrete types. Bond IDL doesn’t support the equivalent of C++ template template parameters.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/generics</code></li>
<li><code>examples/cs/core/generics</code></li>
<li><code>examples/cpp/core/generic_tree</code></li>
</ul>
<h2 id="type-aliases">Type aliases</h2>
<p>The syntax to define type aliases is very similar to C++:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> time = int64;
<span class="kw">using</span> array&lt;T&gt; = vector&lt;T&gt;;</code></pre></div>
<p>An alias can be used in any context where the aliased type could be used, including a definition of another alias:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> times = array&lt;time&gt;;</code></pre></div>
<p>Type aliases can optionally be <a href="#custom-type-mappings">mapped to custom types</a> in the generated code.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/time_alias</code></li>
<li><code>examples/cpp/core/multiprecision</code></li>
<li><code>examples/cpp/core/string_ref</code></li>
<li><code>examples/cpp/core/container_of_pointers</code></li>
<li><code>examples/cpp/core/static_array</code></li>
<li><code>examples/cs/core/date_time</code></li>
<li><code>examples/cs/core/decimal</code></li>
<li><code>examples/cs/core/guid</code></li>
<li><code>examples/cs/core/container_alias</code></li>
</ul>
<h2 id="struct-views">Struct views</h2>
<p>A view definition is syntactic sugar to define a struct that has a subset of the fields of another struct:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Example
{
    <span class="dv">0</span>: int16 x;
    <span class="dv">1</span>: string y;
    <span class="dv">2</span>: list&lt;<span class="dt">bool</span>&gt; z;
}

<span class="kw">struct</span> View view_of Example
{
    x,z;
}</code></pre></div>
<p>In the above example, the definition of <code>View</code> is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> View
{
    <span class="dv">0</span>: int16 x;
    <span class="dv">2</span>: list&lt;<span class="dt">bool</span>&gt; z;
}</code></pre></div>
<p>A view of a generic struct is also a generic struct with the same number of type parameters.</p>
<p>See example: <code>examples/cpp/core/schema_view</code></p>
<h2 id="service-definition">Service definition</h2>
<p>A service definition consists of a service name and methods:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">service Calculator
{
    Result Calculate(Operation);
    <span class="dt">void</span> Configure(Settings);
    Stats GetStats();
}</code></pre></div>
<p>Methods take one parameter and can return a result. A method can return:</p>
<ul>
<li>a <a href="#struct-definition">struct</a></li>
<li><code>void</code></li>
<li><code>nothing</code></li>
</ul>
<p>A method can take as input up to one struct. <code>void</code> may optionally be used in place of a struct name to indicate that the methods doesn’t take any input.</p>
<p>Methods with the result of <code>nothing</code> are one-way, fire and forget methods: the service doesn’t send any response regardless of whether the service method execution resulted in success or failure. This is different from methods returning <code>void</code> which send back a response with an empty payload and may indicate failure using errors.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">service Watchdog
{
    nothing Heartbeat(Identifier);
}</code></pre></div>
<h2 id="generic-service">Generic service</h2>
<p>Generic services are parameterized with one or more type parameters which can be used within the service definition in any place where a concrete type could be used.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">service Gateway&lt;Token&gt;
{
    Result Authenticate(Token);
}</code></pre></div>
<p>The usage of a type parameter within a generic service definition may implicitly constrain what type(s) can be used to instantiate the generic service. For example in the above definition the <code>Token</code> type parameter must be a <a href="#struct-definition">struct</a>.</p>
<h2 id="custom-attributes">Custom attributes</h2>
<p>Struct, service, enum as well as struct field and service method definitions can be annotated with custom attributes which are in effect name, string-values pairs:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[Validate(<span class="st">&quot;True&quot;</span>)]
<span class="kw">struct</span> Example
{
    [Max(<span class="st">&quot;100&quot;</span>)]
    <span class="dv">0</span>: uint32 value;
}

[service_id(<span class="st">&quot;MyExample&quot;</span>)]
service Example
{
    [Tracing(<span class="st">&quot;enabled&quot;</span>)]
    Result Method(Param);
}</code></pre></div>
<p>Attributes are available in code generation templates and thus can be used to drive custom code generation. They are also available to applications via <a href="#compile-time-schema">compile-time</a> and <a href="#runtime-schema">runtime</a> schema, and as <code>Metadata</code> argument in <a href="#transforms">transforms</a> and <a href="#protocols">protocols</a>.</p>
<p>See example: <code>examples/cpp/core/attributes</code></p>
<h2 id="comments">Comments</h2>
<p>Bond IDL supports C++ style comments:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*</span>
<span class="co">    Multi-line </span>
<span class="co">    comment</span>
<span class="co">*/</span>
<span class="kw">struct</span> Example
{
    <span class="co">// One line comment</span>
}</code></pre></div>
<h1 id="schema-ast">Schema AST</h1>
<p>The compiler exposes a JSON representation of the schema Abstract Syntax Tree. The AST is intended for tools that need to access to the schema information contained in Bond IDL files with the full fidelity. The compiler can also take the JSON representation of the AST as an input, enabling tools which programmatically construct/modify Bond schemas.</p>
<h2 id="example">Example</h2>
<p>Given the following schema definition:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> example.some

<span class="kw">struct</span> SomeStruct
{
    <span class="dv">0</span>: int32 someField = <span class="dv">123</span>;
}</code></pre></div>
<p>Below is the JSON representation of the schema’s Abstract Syntax Tree generated using <code>gbc schema example.bond</code> command:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;imports&quot;</span>: [],
  <span class="st">&quot;namespaces&quot;</span>: [
    {
      <span class="st">&quot;name&quot;</span>: [
          <span class="st">&quot;example&quot;</span>,
          <span class="st">&quot;some&quot;</span>
      ]
    }
  ],
  <span class="st">&quot;declarations&quot;</span>: [
    {
      <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Struct&quot;</span>,
      <span class="st">&quot;declNamespaces&quot;</span>: [
        {
          <span class="st">&quot;name&quot;</span>: [
              <span class="st">&quot;example&quot;</span>,
              <span class="st">&quot;some&quot;</span>
          ]
        }
      ],
      <span class="st">&quot;declAttributes&quot;</span>: [],
      <span class="st">&quot;declParams&quot;</span>: [],
      <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;SomeStruct&quot;</span>,
      <span class="st">&quot;structFields&quot;</span>: [
        {
          <span class="st">&quot;fieldOrdinal&quot;</span>: <span class="dv">0</span>,
          <span class="st">&quot;fieldType&quot;</span>: <span class="st">&quot;int32&quot;</span>,
          <span class="st">&quot;fieldName&quot;</span>: <span class="st">&quot;someField&quot;</span>,
          <span class="st">&quot;fieldDefault&quot;</span>: {
            <span class="st">&quot;value&quot;</span>: <span class="dv">123</span>,
            <span class="st">&quot;type&quot;</span>: <span class="st">&quot;integer&quot;</span>
          }
        }
      ]
    }
  ]
} </code></pre></div>
<h2 id="bond">Bond</h2>
<p>The top level JSON object represents the parsed Bond IDL file and has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;imports&quot;</span>: [
  ],
  <span class="st">&quot;namespaces&quot;</span>: [
  ],
  <span class="st">&quot;declarations&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>imports</code> is an array of <a href="#import">imports</a>.</li>
<li><code>namespaces</code> is an array of <a href="#namespace">namespaces</a>. Each Bond file should have one namespace declaration, although the AST and IDL syntax have support for legacy schema files with multiple, language-specific namespaces.</li>
<li><code>declarations</code> is an array of <a href="#declaration">declarations</a>.</li>
</ul>
<h2 id="import">Import</h2>
<p>Imports are represented by JSON strings. For example the following IDL:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">import <span class="st">&quot;bond/core/bond.bond&quot;</span></code></pre></div>
<p>is represented in the AST as:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;bond/core/bond.bond&quot;</span></code></pre></div>
<h2 id="namespace">Namespace</h2>
<p>The namespace declaration is represented by a JSON object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;name&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>name</code> is <a href="#qualified-name">qualified name</a> of the namespace.</li>
</ul>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> foo.bar</code></pre></div>
<p>is represented as:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;name&quot;</span>: [
    <span class="st">&quot;foo&quot;</span>,
    <span class="st">&quot;bar&quot;</span>
  ]
}</code></pre></div>
<h2 id="declaration">Declaration</h2>
<p>A declaration is represented by a JSON object with the following common properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Tag&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;Name&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;declAttributes&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>tag</code> is a string indicating the type of the declaration. It can have one of the following values: <code>&quot;Struct&quot;</code>, <code>&quot;Enum&quot;</code>, <code>&quot;Alias&quot;</code>, <code>&quot;Forward&quot;</code>, <code>&quot;Service&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;Event&quot;</code>.</li>
<li><code>declNamespaces</code> is an array of one or more <a href="#namespace">namespaces</a>.</li>
<li><code>declName</code> is a string.</li>
<li><code>declParams</code> is an array of zero or more <a href="#type-parameter">type parameters</a>. The property doesn’t apply to <a href="#enum"><code>Enum</code></a> declarations.</li>
<li><code>declAttributes</code> is an array of zero or more <a href="#attribute">attributes</a>. The property doesn’t apply to <a href="#forward-declaration"><code>Forward</code></a> declarations.</li>
</ul>
<h3 id="struct">Struct</h3>
<p>A JSON object representing a <code>Struct</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Struct&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;StructName&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;declAttributes&quot;</span>: [
  ],
  <span class="st">&quot;structBase&quot;</span>: null,
  <span class="st">&quot;structFields&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>structBase</code> is <code>null</code> or a <a href="#type">type</a> representing the struct base. The property is optional and may be omitted.</li>
<li><code>structFields</code> is an array of zero or more <a href="#struct-field">fields</a>.</li>
</ul>
<h3 id="service">Service</h3>
<p>A JSON object representing a <code>Service</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Service&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;ServiceName&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;declAttributes&quot;</span>: [
  ],
  <span class="st">&quot;serviceMethods&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>serviceMethods</code> is an array of zero or more <a href="#methods">methods</a>.</li>
</ul>
<h4 id="methods">Methods</h4>
<p>A JSON object representing a <code>Function</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Function&quot;</span>,
  <span class="st">&quot;methodName&quot;</span>: <span class="st">&quot;methodName&quot;</span>,
  <span class="st">&quot;methodAttributes&quot;</span>: [
  ],
  <span class="st">&quot;methodResult&quot;</span>: {
  },
  <span class="st">&quot;methodInput&quot;</span>: {
  }
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>methodResult</code> is a user defined type struct, alias to struct, parameter or null.</li>
<li><code>methodInput</code> is a user defined type struct, alias to struct, parameter or null.</li>
<li><code>methodAttributes</code> is an array of zero or more <a href="#attribute">attributes</a></li>
</ul>
<p>A JSON object representing an <code>Event</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Event&quot;</span>,
  <span class="st">&quot;methodName&quot;</span>: <span class="st">&quot;methodName&quot;</span>,
  <span class="st">&quot;methodAttributes&quot;</span>: [
  ],
  <span class="st">&quot;methodInput&quot;</span>: {
  }
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>methodInput</code> is a user defined type struct, alias to struct, parameter or null.</li>
<li><code>methodAttributes</code> is an array of zero or more <a href="#attribute">attributes</a></li>
</ul>
<h3 id="enum">Enum</h3>
<p>A JSON object representing an <code>Enum</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Enum&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;EnumName&quot;</span>,
  <span class="st">&quot;declAttributes&quot;</span>: [
  ],
  <span class="st">&quot;enumConstants&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>enumConstants</code> is an array of one or more <a href="#constant">constants</a>.</li>
</ul>
<h4 id="constant">Constant</h4>
<p>An enum constant is represented by the following JSON object:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;constantName&quot;</span>: <span class="st">&quot;ConstantName&quot;</span>,
  <span class="st">&quot;constantValue&quot;</span>: null
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>constantName</code> is a string.</li>
<li><code>constantValue</code> is an integer or <code>null</code> if the value is not explicitly defined. The property is optional and may be omitted.</li>
</ul>
<h3 id="type-alias">Type alias</h3>
<p>A JSON object representing a type alias declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Alias&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;AliasName&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;aliasType&quot;</span>: {
  }
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>aliasType</code> is the aliased <a href="#type"><code>type</code></a>.</li>
</ul>
<h3 id="forward-declaration-1">Forward declaration</h3>
<p>A JSON object representing a forward declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Forward&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;StructName&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ]
}</code></pre></div>
<h3 id="service-1">Service</h3>
<p>A JSON object representing a <code>Service</code> declaration has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Service&quot;</span>,
  <span class="st">&quot;declNamespaces&quot;</span>: [
  ],
  <span class="st">&quot;declName&quot;</span>: <span class="st">&quot;ServiceName&quot;</span>,
  <span class="st">&quot;declParams&quot;</span>: [
  ],
  <span class="st">&quot;declAttributes&quot;</span>: [
  ],
  <span class="st">&quot;serviceMethods&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>serviceMethods</code> is an array of zero or more <a href="#service-method">methods</a>.</li>
</ul>
<h2 id="qualified-name">Qualified name</h2>
<p>Qualified names are represented in JSON by an array of strings. For example:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">foo.bar</code></pre></div>
<p>is represented by:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[ <span class="st">&quot;foo&quot;</span>,
  <span class="st">&quot;bar&quot;</span>
]</code></pre></div>
<h2 id="type-parameter">Type parameter</h2>
<p>Type parameters are represented by JSON objects with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;paramName&quot;</span>: <span class="st">&quot;T&quot;</span>,
  <span class="st">&quot;paramConstraint&quot;</span>: null
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>paramName</code> is a string.</li>
<li><code>paramConstraint</code> is <code>null</code> or the string <code>&quot;value&quot;</code>. The property is optional and may be omitted.</li>
</ul>
<h2 id="attribute">Attribute</h2>
<p>Attributes are represented by JSON objects with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;attrName&quot;</span>: [
  ],
  <span class="st">&quot;attrValue&quot;</span>: <span class="st">&quot;Value&quot;</span>
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>attrName</code> is a <a href="#qualified-name">qualified name</a>.</li>
<li><code>attrValue</code> is a string.</li>
</ul>
<h2 id="struct-field">Struct field</h2>
<p>A struct field is represented by a JSON object with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;fieldModifier&quot;</span>: <span class="st">&quot;Optional&quot;</span>,
  <span class="st">&quot;fieldDefault&quot;</span>: null,
  <span class="st">&quot;fieldType&quot;</span>: {
  },
  <span class="st">&quot;fieldName&quot;</span>: <span class="st">&quot;name&quot;</span>,
  <span class="st">&quot;fieldAttributes&quot;</span>: [
  ],
  <span class="st">&quot;fieldOrdinal&quot;</span>: <span class="dv">0</span>
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>fieldModifier</code> is one of the following strings: <code>&quot;Optional&quot;</code>, <code>&quot;Required&quot;</code>, <code>&quot;RequiredOptional&quot;</code>. The property is optional and <code>fieldModifier</code> defaults to <code>Optional</code> if omitted.</li>
<li><code>fieldDefault</code> is <code>null</code> or a <a href="#field-default-value">default value</a>. The property is optional and may be omitted.</li>
<li><code>fieldType</code> is a <a href="#type">type</a>.</li>
<li><code>fieldName</code> is a string.</li>
<li><code>fieldAttributes</code> is an array of zero or more <a href="#attribute">attributes</a>. The property is optional an may be omitted.</li>
<li><code>fieldOrdinal</code> is an integer.</li>
</ul>
<h3 id="field-default-value">Field default value</h3>
<p>A field default value is represented by a JSON object with the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;enum&quot;</span>,
  <span class="st">&quot;value&quot;</span>: <span class="st">&quot;Value2&quot;</span>
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>type</code> is one of the following strings: <code>&quot;enum&quot;</code>, <code>&quot;bool&quot;</code>, <code>&quot;integer&quot;</code>, <code>&quot;float&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;nothing&quot;</code>.</li>
<li><code>value</code> is a value appropriate for the type. The <code>value</code> property is not used when <code>type</code> is <code>&quot;nothing&quot;</code>.</li>
</ul>
<h2 id="type">Type</h2>
<h3 id="basic-types">Basic types</h3>
<p>Basic types are represented by JSON strings:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;int8&quot;</span>
<span class="st">&quot;int16&quot;</span>
<span class="st">&quot;int32&quot;</span>
<span class="st">&quot;int64&quot;</span>
<span class="st">&quot;uint8&quot;</span>
<span class="st">&quot;uint16&quot;</span>
<span class="st">&quot;uint32&quot;</span>
<span class="st">&quot;uint64&quot;</span>
<span class="st">&quot;float&quot;</span>
<span class="st">&quot;double&quot;</span>
<span class="st">&quot;bool&quot;</span>
<span class="st">&quot;string&quot;</span>
<span class="st">&quot;wstring&quot;</span>
<span class="st">&quot;blob&quot;</span></code></pre></div>
<h3 id="complex-types">Complex types</h3>
<p>Complex types are represented by JSON objects with a <code>type</code> property indicating the complex type. If the <code>type</code> property is one of the following: <code>&quot;vector&quot;</code>, <code>&quot;list&quot;</code>, <code>&quot;set&quot;</code>, <code>&quot;nullable&quot;</code>, <code>&quot;maybe&quot;</code>, <code>&quot;bonded&quot;</code> then the object has the following structure:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;vector&quot;</span>,
  <span class="st">&quot;element&quot;</span>: {
  }
}</code></pre></div>
<p>where <code>element</code> is the <a href="#type">type</a> of the element (or the nested type).</p>
<p>Other complex types are:</p>
<ul>
<li><p>map</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;map&quot;</span>,
  <span class="st">&quot;key&quot;</span>: {
  },
  <span class="st">&quot;element&quot;</span>: {
  }
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>key</code> is the <a href="#type">type</a> of the map key.</li>
<li><code>element</code> is the <a href="#type">type</a> of map value.</li>
</ul></li>
<li><p>type parameter</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;parameter&quot;</span>,
  <span class="st">&quot;value&quot;</span>: {
  }
}</code></pre></div>
<p>where <code>value</code> is a <a href="#type-parameter">type parameter</a>.</p></li>
<li><p>numeric type argument</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;constant,</span>
  <span class="st">&quot;value&quot;</span>: <span class="dv">0</span>
}</code></pre></div>
<p>where <code>value</code> is an integer.</p></li>
<li><p>user defined type</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;type&quot;</span>: <span class="st">&quot;user&quot;</span>,
  <span class="st">&quot;declaration&quot;</span>: {
  },
  <span class="st">&quot;arguments&quot;</span>: [
  ]
}</code></pre></div>
<p>where:</p>
<ul>
<li><code>declaration</code> is a <a href="#declaration">declaration</a> of a user defined type.</li>
<li><code>arguments</code> is an array of zero or more <a href="#type">types</a> representing type arguments for a generic user defined type. The property is optional and may be omitted for non-generic types.</li>
</ul></li>
</ul>
<h2 id="service-method">Service method</h2>
<p>A JSON object representing a <code>Method</code> has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;tag&quot;</span>: <span class="st">&quot;Tag&quot;</span>,
  <span class="st">&quot;methodName&quot;</span>: <span class="st">&quot;MethodName&quot;</span>,
  <span class="st">&quot;methodAttributes&quot;</span>: [
  ],
  <span class="st">&quot;methodResult&quot;</span>: {
  },
  <span class="st">&quot;methodInput&quot;</span>: {
  }
}</code></pre></div>
<p>where</p>
<ul>
<li><code>tag</code> is one of the following string values:
<ul>
<li><code>&quot;Sink&quot;</code> to represent a one-way method that doesn’t return any result.</li>
<li><code>&quot;Function&quot;</code> to represent a method that returns a result.</li>
</ul></li>
<li><code>methodName</code> is a string.</li>
<li><code>methodAttributes</code> is an array of zero or more <a href="#attribute">attributes</a>.</li>
<li><code>methodResult</code> is an object representing <a href="#message">message</a> returned from the method as the result.</li>
<li><code>methodInput</code> is an object representing <a href="#message">message</a> accepted by the method as the input.</li>
</ul>
<h3 id="message">Message</h3>
<p>A JSON object representing a <code>Message</code> has the following properties:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;messagePayload&quot;</span>: {
  },
  <span class="st">&quot;messageService&quot;</span>: {
  }
}</code></pre></div>
<p>where</p>
<ul>
<li><code>messagePayload</code> is <code>null</code> or an object representing <a href="#type">type</a> of data payload carried by the message. The type must be a user defined struct.</li>
<li><code>messageService</code> is <code>null</code> or an object representing <a href="#service-type">type of a service</a> that can be passed in the message, e.g. as a callback.</li>
</ul>
<h3 id="service-type">Service type</h3>
<p>Service type can be specified using one of the following JSON objects:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;typeParam&quot;</span>: {
  }
}</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;declaration&quot;</span>: {
  },
  <span class="st">&quot;arguments&quot;</span>: {
  }
}</code></pre></div>
<p>where</p>
<ul>
<li><code>typeParam</code> is an object representing <a href="#type-parameter">type parameter</a>.</li>
<li><code>declaration</code> is a <a href="#service">service declaration</a>.</li>
<li><code>arguments</code> is an array of zero or more <a href="#type">types</a> representing type arguments for a generic service. The property is optional and may be omitted for non-generic services.</li>
</ul>
<h1 id="runtime-schema">Runtime Schema</h1>
<p>Bond defines <code>SchemaDef</code> structure to represent Bond schemas at runtime. <code>SchemaDef</code> is accepted as an argument by various Bond APIs. For example when transcoding binary payload into a text protocol like JSON, the <code>SchemaDef</code> of the payload is used to provide the necessary meta-data such as names of the fields.</p>
<p>Usually <code>SchemaDef</code> is produced at runtime using Bond APIs. However in some scenarios it may be desirable to be able to obtain <code>SchemaDef</code> object(s) directly from a schema definition IDL file. The compiler can generate <code>SchemaDef</code> serialized in Simple JSON protocol which can be deserialized using standard Bond APIs.</p>
<h2 id="example-1">Example</h2>
<p>Given the following schema definition contained a file <code>example.bond</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> example.some

<span class="kw">struct</span> SomeStruct
{
    <span class="dv">0</span>: int32 someField = <span class="dv">123</span>;
}</code></pre></div>
<p>The command <code>gbc schema --runtime-schema example.bond</code> would produce a file named <code>example.SomeStruct.json</code> with the following content:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
  <span class="st">&quot;structs&quot;</span>: [
    {
      <span class="st">&quot;metadata&quot;</span>: {
        <span class="st">&quot;qualified_name&quot;</span>: <span class="st">&quot;example.some.SomeStruct&quot;</span>,
        <span class="st">&quot;name&quot;</span>: <span class="st">&quot;SomeStruct&quot;</span>
      },
      <span class="st">&quot;fields&quot;</span>: [
        {
          <span class="st">&quot;metadata&quot;</span>: {
            <span class="st">&quot;default_value&quot;</span>: {
              <span class="st">&quot;int_value&quot;</span>: <span class="dv">123</span>
            },
            <span class="st">&quot;name&quot;</span>: <span class="st">&quot;someField&quot;</span>
          },
          <span class="st">&quot;id&quot;</span>: <span class="dv">0</span>,
          <span class="st">&quot;type&quot;</span>: {
            <span class="st">&quot;id&quot;</span>: <span class="dv">16</span>
          }
        }
      ]
    }
  ]
}</code></pre></div>
<h1 id="library">Library</h1>
<p>The Bond IDL compiler and codegen functionality is accessible programatically via the <a href="https://hackage.haskell.org/package/bond">bond</a> Haskell package. The library can be used to implement custom codegen tools. See examples/codegen in the repository.</p>
</div>
</div>
</body>
</html>
