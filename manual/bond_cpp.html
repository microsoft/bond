<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>A Young Person’s Guide to C++ Bond</title>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  body {
      line-height: 1.5; 
      font-family: Helvetica, Arial, sans-serif; 
      color: #333333;
      font-size: 1em;
  }
  code {
      font-size: 1em;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace, serif;
  }
  td.lineNumbers { width: 40px; }
  div#all {
    max-width: 1120px;
    background-color: #ffffff;
    margin: 0 auto;
    padding: 25px;
    overflow: auto;
  }
  code > span.kw { color: #204a87; font-weight: normal; } /* Keyword */  
  code > span.co { color: #4E9A06; font-style: normal; }
  code > span.st { color: #8A0303; font-style: normal; }
  code > span.cf { color: #204a87; font-weight: normal; } /* ControlFlow */
  code > span.op { color: #000000; font-weight: normal; } /* Operator */
  code > span.pp { color: #8f5902; font-style: normal; } /* Preprocessor */
  code > span.ex { } /* Extension */
  code > span.at { color: #c4a000; } /* Attribute */
  code > span.do { color: #8f5902; font-weight: normal; font-style: normal; } /* Documentation */
  code > span.an { color: #8f5902; font-weight: normal; font-style: normal; } /* Annotation */
  code > span.cv { color: #8f5902; font-weight: normal; font-style: normal; } /* CommentVar */
  code > span.in { color: #8f5902; font-weight: normal; font-style: normal; } /* Information */

  h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    border-bottom: 1px solid black;
  }

  div.sourceCode {
    overflow-x: auto;
    max-height: 620px;
  }

  table.sourceCode { 
    line-height: 120%;
  } 

  #toc {
    width: 300px; 
    position:fixed;
    overflow: auto;
    height: 95%;
  }

  #main {
    margin-left: 320px;  
    margin-rigth: auto;
    max-width: 800px;
  }
  a {
    text-decoration: none;
  }
  #toc a:visited {
    color: #99c;
  }
  #main a:visited {
    color: #36c;
  }
  a:link {
    color: #36c;
  }
  @media screen and (max-width: 979px){
  #main {
    margin-left: auto;
    margin-right: auto;
  }
  #toc {
    left: -300px; 
  }
  }
  </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58775439-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav id="TOC"></nav>
<div id="all">
<div id="toc">
<ul>
<li><a href="#about">About</a></li>
<li><a href="#basic-example">Basic example</a></li>
<li><a href="#serialization">Serialization</a></li>
<li><a href="#marshaling">Marshaling</a></li>
<li><a href="#default-value-of-nothing">Default value of <code>nothing</code></a></li>
<li><a href="#nullable-types">Nullable types</a></li>
<li><a href="#runtime-schema">Runtime schema</a></li>
<li><a href="#compile-time-schema">Compile-time schema</a></li>
<li><a href="#understanding-bondedt">Understanding <code>bonded&lt;T&gt;</code></a><ul>
<li><a href="#lazy-deserialization">Lazy deserialization</a></li>
<li><a href="#protocol-transcoding">Protocol transcoding</a></li>
<li><a href="#pass-through">Pass-through</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
<li><a href="#bonus-explainer-parallels-between-bondedt-and-c-pointers">Bonus explainer: parallels between <code>bonded&lt;T&gt;</code> and C++ pointers</a></li>
</ul></li>
<li><a href="#merge">Merge</a></li>
<li><a href="#required-fields">Required fields</a></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#transforms">Transforms</a><ul>
<li><a href="#transform-concept">Transform concept</a></li>
</ul></li>
<li><a href="#reflection">Reflection</a></li>
<li><a href="#protocols">Protocols</a><ul>
<li><a href="#compact-binary">Compact Binary</a></li>
<li><a href="#fast-binary">Fast Binary</a></li>
<li><a href="#simple-binary">Simple Binary</a></li>
<li><a href="#simple-json">Simple JSON</a></li>
</ul></li>
<li><a href="#custom-type-mappings">Custom type mappings</a><ul>
<li><a href="#codegen-parameters">Codegen parameters</a></li>
<li><a href="#container-concept">Container concept</a></li>
<li><a href="#string-concept">String concept</a></li>
<li><a href="#scalar-concept">Scalar concept</a></li>
</ul></li>
<li><a href="#custom-allocators">Custom allocators</a></li>
<li><a href="#custom-streams">Custom streams</a></li>
<li><a href="#scoped-enumerations">Scoped enumerations</a></li>
<li><a href="#exceptions">Exceptions</a><ul>
<li><a href="#bondexception"><code>bond::Exception</code></a></li>
<li><a href="#stdbad_alloc"><code>std::bad_alloc</code></a></li>
<li><a href="#stdlength_error"><code>std::length_error</code></a></li>
<li><a href="#stdrange_error"><code>std::range_error</code></a></li>
</ul></li>
<li><a href="#optimizing-build-time">Optimizing build time</a></li>
<li><a href="#references">References</a><ul>
<li><a href="#c-api-referenceapi_reference"><a href="../reference/cpp/index.html">C++ API reference</a></a></li>
<li><a href="#bond-compiler-referencecompiler"><a href="compiler.html">Bond compiler reference</a></a></li>
<li><a href="#c-users-manualbond_cs"><a href="bond_cs.html">C# User’s Manual</a></a></li>
<li><a href="#python-users-manualbond_py"><a href="bond_py.html">Python User’s Manual</a></a></li>
</ul></li>
</ul>
</div>
<div id="main">
<div id="header">    
<h1 class="title">A Young Person’s Guide to C++ Bond</h1>
</div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAB3RJTUUH4AkNAgoHQuWiyQAACYlJREFUeNrtm3twVNUdxz/33t3N7pL3OyRkISQQKiBoCGApoK2KVKlUHhVQwFZQWywWxnGm7egwtkWdoVREitFQXhYoRRSICsFYaSU2nQRMAoEEyIu8YEM2m93N3rt7T/9IGo20dKG0JGW/M/vH3Xv3nHs+5/f7nd/53buSEEJwE0vmJlcQQBBAEEAQQBBAEEAQQBBAEEAQQBDAzSnD9WjE4XDwccFHFBWXcMF+CVVVURQFi9lMRHgYMVFRJCbEkZSURGxMLGaLhcSkJEJDQ284AOl6bIfnPfw9CpzhmBMGoxiNSJKMEAIhdHSfD+FT8Xs9aB1tCHc7ZmcTM7JHsG79673acblc5OcfInN4JsMzM/uuBfg0jUsOBzU1tVxqbeXjk3XEz3wmANwSsjGExkPbsKUOuuz0htdf57kXX8EvKdBuJ9mWyrjbbyM76zbmzplDWlrajQXg8XjIy8tj48YccFfwrRG1FJRHog+cHVgDQiA0L81H9pKw+NvU1taSmprac9rrdpE05SHiJs3A7+5AdbZyvP0SB7ft5/PjZbz66lri4mL/Ny7g8/nQNI2GhgZ2797Nzp07KS0tZXx2FsWfn+FkjorN5mDYghik+1dhjo4PqEPnuXJCinYRExXF8ePH6ezsJDU1lXHjxlF2rBh1yvexpmQgdL3rBhUDF3avZkJEGUeOuxmamcW77+0nPj7++ltAW1sb+fn5HD16lJMVFWjeTqwWM7IsM3bMKH70xA8YPnwYix7/MbaUKs6eGUCVI5xbEwehq96AOrx4soh1zz7LwoULAfD7/VRXV3PixAmWFRYSmTIMofu/mCFZZohUzh9/5oEQhTU7ypkzdx4fHT6ILMvXF8CuXbtYunQpyckDeWX1L0hMiKel5QJeVWXIYBvVNbU0NrVwyyAPCJV3PhEkTbgb4fcH7ALGjgssX76cRYsWkZycTHZ2NhMnTuzy77ghIF1mpJh0N7ouI6t+MlMVVmz4EwaDgbCwMEaPHk12djZZWVlkZWWRlpaGoijXBmDJkiXMmjWLvLw83t1/gJaWJgZYzdw+diwREeEMSx9K+clKRtmc4JP5S6lG9NQ7es3YlccvSIkKpbDoPA0NDZw+fYrKyiqqa2rYtnUr3uSsHtP/0q/wMADV58asgKZ6WfLEk2zc8Cr19fVUVlZy6tQpiouL2bNnD2VlZaxatYrZs2dfWxCMjo5mwYIFzJ8/H1VVqampYf369Ty66HEGD7YxJC2DxVkevG5o0aJRBkQh/CqSLHeDkK6wCEg0+kKIS0hEtoSB1G3CXhd+JFImPwZfCUnC7+ec5Q7ONRcwwuanzm7kD7t2IgmVcePGMX78eO68886e63fs2EF7e/t/Jw/Iz89nzdp1TE7+iGUP6Ez55RB8019EkmTObn6B2An3E5YxFmQFdB9eeyNqWwt6pxtjZByWgUORDSZkg6EblOgxcyF0/N5OEPpl/Xoddpz7Xmb9gjpe2K6w7q2DlJaWUl5eTlVVFXa7HbPZTGRkJK2trSxdurQnxlz3RMjlcjF/3lwO5R1AirOR/tRa/B4XJ1Y/Suay39B5sQFHxV9xVBRhSbARarsFU3Q89sIDDJr7LMaImMtmOYDbRNe8tB7dS2PBbhY+soA3czf1+LqqqqiqitfrRdM0oqKiCAkJ+e9mgg6Hg3vuuZv2OxZjSbTR+rd82ko/wRAWTeiQkUSMGI9iCUP3a6DrNHywicSpc5BMli/N/FViMJiQZYm6g9sZKdv58P0DmEymG5cKlxQXM/Xe6bitcSTcPpXIjLGYYgYCAuHzIYTeNdvdKbEkK9c8+N53LdN45B0mmC/x3r79N34v8H7eAfbu2UPRZ4U4OlwISyT6gCh0SwS6JQzMYSihkRgsoUjGECRFwWAwoSMjyXIXGElCMRpQQqwB9amYrVSs/SEf7NjE5ClTbyyAXumy243D4cDpdOLq6MDldtHhdGK327l48SKtbQ7cnV5yc9/gvolm/H5weE2oPoljZyF5yVqETw3IClR7A+Nbj5K7ees1J0UGrrMsVisWq5XEpKR/ec2nn37KmSOr2bq8eyWQAKFw7wo/LeiBOYnQMUbFU/DJOTRNCzjo3fCCiBCCmbPm89JSC/gATQJVAj8MMIHf1Q6SFJj5SjJ2JYLCwsL+UxH69dr1LJjsIN3muSweWq0GvK1NSAECAIgaOpI338rtHwBqa2vZvWUVLy1ygrd7kGaotYfwyGpBQVkYXnvjFxliAAq3ZbJ3796+D8DlcjF2zGjWPu7CIHftHTp9ISx/LYwxT4Xw8E/2serFX+Fqqg7YBQBCohPpUP3U19X1jSD4z9Ta2so3757OynmxONrP8PPN8Hl9NJ3WSXxnxgNc3PEYsixTcPgwrrpKJFlBoAUWU3Sd8KGjOFZSQsqgQX0TQE5ODseKP0N1Z1B/1xPMXPwQP500CaPR2Gvr+rWRI/GcP4t0FW0LoRNqG8GJ8lLunzHjxucB/6mMFivDn/ltwAmRJCu46k5yl+80G3N/1/+fC3x94kTcLfVXZQGW+EE0NTVyLXPZ5wBMv28arqbarnKZpyOgKpNiCcPp7kTTtP4P4LsPPoizrhKQaPxwc0DVJiHAo8v4fL7+DyA5JYUkkwYIJEnC1+G4fFn86rEQeIWMP9DaZF8GYDKZGJUYjvC6ic66h5odL6EYzV0VJEkGBN6W+i8gSBKSwYQqGdD/HwAoisK0adNo+fNeQtPHEnnrFKpynkO1N+CpLuP0a8vpbKlBkhX8nW7c58/Q8mEuSnvLVSVQfXYZhK4nUFExsaQ//RqGsGhc1eW4qstRTBYiRn8DraOdM/nvMSb8LEnyeUTkVDZt2UpsbOxV7SP6LACALVu28OTLOaTPWtZdZNXRnHaa9m0gjZNsXGFmjK2DbUdieHKNE7ens28URK6nnn56GW+8X4g1OZ22yuPcO/giK2Z6cDi97CsUHCpRGJg2nt9ve4v09PRr3p/3aRUXF4ucnBzx9ttvC0BYrVaxePFikZGRIboLjMJisYiVK1eK06dPCyGE0HVd6Lre08Y/jhsbG3t9L4QQUn96XV4I0ePjeXl5rFmzhsOHD/euSFkspKenEx8fj9lsRlVVmpubqaioQFVVtm/fzrx58/qPBVxJmqaJpqYm8fzzz4vExMQei7jSp6ioqP9awL9TQ0MDJSUlVFVV0dzcjMfjwWQykZCQQGZmJpMnT77stRwp+I+Rm1xBAEEAQQBBAEEAQQBBAEEAQQBBAEEAN6f+DmFDv1c4Q3HPAAAAAElFTkSuQmCC" alt="The Bond logo: a stylized glue gun" /><br />
</p>
<h1 id="about">About</h1>
<p>Bond is an extensible framework for working with schematized data. It is suitable for scenarios ranging from service communications to Big Data storage and processing.</p>
<p>Bond defines a rich type system and schema versioning rules which allow forward and backward compatibility. The core Bond features include high performance serialization/deserialization and a very powerful, generic data transform mechanism. The framework is highly extensible via pluggable serialization protocols, data streams, user defined type aliases and more.</p>
<p>By design Bond is language and platform independent and is currently supported for C++, C#, and Python on Linux, OS X and Windows.</p>
<p>Bond is published on GitHub at <a href="https://github.com/Microsoft/bond/" class="uri">https://github.com/Microsoft/bond/</a>.</p>
<h1 id="basic-example">Basic example</h1>
<p>In Bond data schemas are defined using idl-like <a href="compiler.html#idl-syntax">syntax</a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">namespace</span> example

<span class="kw">struct</span> Record
{
    <span class="dv">0</span>: string          name;
    <span class="dv">1</span>: vector&lt;<span class="dt">double</span>&gt;  items;
}</code></pre></td></tr></table></div>
<p>In order to use the schema in a C++ program, it needs to be compiled using the Bond compiler <a href="compiler.html"><code>gbc</code></a>. This step is sometimes also referred to as code generation (or codegen) because the compilation generates C++ code corresponding to the schema definition.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">gbc c++ example.bond</code></pre></td></tr></table></div>
<p>Using the generated C++ code, we can write a simple program that will serialize and deserialize an instance of the Record schema using <a href="#compact-binary">Compact Binary</a> protocol:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="ot">#include &quot;example_reflection.h&quot;</span>

<span class="ot">#include &lt;bond/core/bond.h&gt;</span>
<span class="ot">#include &lt;bond/stream/output_buffer.h&gt;</span>

<span class="dt">int</span> main()
{
    example::Record src;

    src.name = <span class="st">&quot;test&quot;</span>;
    src.items.push_back(<span class="fl">3.14</span>);

    bond::OutputBuffer output;
    bond::CompactBinaryWriter&lt;bond::OutputBuffer&gt; writer(output);

    Serialize(src, writer);

    bond::InputBuffer input(output.GetBuffer());
    bond::CompactBinaryReader&lt;bond::InputBuffer&gt; reader(input);

    example::Record dst;

    Deserialize(reader, dst);

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></td></tr></table></div>
<h1 id="serialization">Serialization</h1>
<p>The core feature provided by Bond is the ability to serialize and deserialize instances of user-defined schemas. The serialization APIs are declared in the <code>bond\core\bond.h</code> header file:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Writer&gt;
<span class="dt">void</span> Serialize(<span class="dt">const</span> T&amp; obj, Writer&amp; output);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
<span class="dt">void</span> Deserialize(Reader input, T&amp; obj);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
T Deserialize(Reader input);</code></pre></td></tr></table></div>
<p>The <code>Reader</code> and <code>Writer</code> template parameters specify the serialization protocol, and are one of the layers at which Bond serialization can be customized to meet applications’ needs. The protocol defines how serialized data is encoded (e.g. binary, text). Bond ships with several <a href="#protocols">built-in protocols</a> optimized for various scenarios, and also supports user-defined <a href="#custom-protocols">protocols</a>. By convention, protocol implementation is split between two classes implementing the reader, and the writer:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> Buffer&gt;
<span class="kw">class</span> CompactBinaryReader;

<span class="kw">template</span> &lt;<span class="kw">typename</span> Buffer&gt;
<span class="kw">class</span> CompactBinaryWriter;</code></pre></td></tr></table></div>
<p>The <code>Buffer</code> template parameter specifies where the serialized payload is respectively read from and written to. This constitutes the second layer of customization. Bond comes with built-in buffers implemented on top of memory <a href="../reference/cpp/classbond_1_1blob.html">blobs</a>, <code>InputBuffer</code> and <code>OutputBuffer</code>, but applications can also define <a href="#custom-buffers">custom buffers</a> by implementing simple stream interfaces.</p>
<p>The full protocol class names can be unwieldy and it is often convenient to define shorter type aliases:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">typedef</span> bond::InputBuffer Input;
<span class="kw">typedef</span> bond::CompactBinaryReader&lt;Input&gt; Reader;
<span class="kw">typedef</span> bond::OutputBuffer Output;
<span class="kw">typedef</span> bond::CompactBinaryWriter&lt;Output&gt; Writer;</code></pre></td></tr></table></div>
<p>which then can be used throughout application code:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">Output output;
Writer writer(output);
Serialize(obj1, writer);

Reader reader(output.GetBuffer());
Deserialize(reader, obj2);</code></pre></td></tr></table></div>
<p>In storage scenarios, when untagged protocols, such as the <a href="#simple-protocol">Simple Protocol</a>, are used, applications need to specify the payload schema during deserialization. The deserialization API has an overloaded version to accommodate this usage:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
<span class="dt">void</span> Deserialize(Reader input, T&amp; obj, <span class="dt">const</span> RuntimeSchema&amp; schema);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
T Deserialize(Reader input, <span class="dt">const</span> RuntimeSchema&amp; schema);</code></pre></td></tr></table></div>
<p>Typically the <a href="#runtime-schema">runtime schema</a> is stored together with the data, for example in a system table or a header of a data file. Since Bond may need to access the runtime schema after the <code>Deserialize</code> function returns (to support <a href="#lazy-deserialization">lazy deserialization</a>), it is recommended that applications manage lifetime of the schema object using smart pointers:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">boost::shared_ptr&lt;bond::SchemaDef&gt; schema(boost::make_shared&lt;bond::SchemaDef&gt;());

<span class="co">// Deserialize the runtime schema</span>
bond::CompactBinaryReader&lt;bond::InputBuffer&gt; cb_reader(schema_data);
bond::Deserialize(cb_reader, *schema);

<span class="co">// Deserialize the object using the runtime schema</span>
bond::SimpleBinaryReader&lt;bond::InputBuffer&gt; simple_reader(object_data);
Deserialize(simple_reader, obj, schema);</code></pre></td></tr></table></div>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/serialization</code></li>
</ul>
<h1 id="marshaling">Marshaling</h1>
<p>Since Bond supports multiple serialization <a href="#protocols">protocols</a>, application endpoints either have to agree on a particular protocol, or include protocol metadata in the payload. Marshaling APIs provide the standard way to do the latter, by automatically adding a payload header with the protocol identifier and version.</p>
<p><code>Marshal</code> and <code>Unmarshal</code> APIs are very similar to <code>Serialize</code> and <code>Deserialize</code>, except that when calling <code>Unmarshal</code> the application simply provides an input stream with payload data, rather than an instance of a particular protocol reader:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">    bond::OutputBuffer output;
    bond::CompactBinaryWriter&lt;bond::OutputBuffer&gt; writer(output);

    Marshal(src, writer);

    bond::InputBuffer input(output.GetBuffer());

    Unmarshal(input, dst);</code></pre></td></tr></table></div>
<p>See example: <code>examples/cpp/core/marshaling</code>.</p>
<h1 id="default-value-of-nothing">Default value of <code>nothing</code></h1>
<p>Fields of a Bond defined struct always have a default value, either explicitly specified in the .bond file, or the implicit system default (<code>false</code> for <code>bool</code>, 0 for arithmetic types, empty for strings/containers and <code>null</code> for <code>nullable&lt;T&gt;</code>). Default values of fields matter because this is what an application will see after deserialization for any optional field that wasn’t present in the payload (e.g. when the payload was created from an older version of the schema). Sometimes it is necessary to distinguish between any of the possible values of a field and absence of a value. To support such scenarios Bond allows fields’ default values to be explicitly set to <code>nothing</code> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> AboutNothing
{
    <span class="dv">0</span>: uint16 n = nothing;
    <span class="dv">1</span>: string name = nothing;
    <span class="dv">2</span>: list&lt;<span class="dt">float</span>&gt; floats = nothing;
}</code></pre></td></tr></table></div>
<p>Setting a field’s default to <code>nothing</code> doesn’t affect schema type of the field, however it may affect what type the field is mapped to in the generated code. The reason why is pretty obvious: some types such as <code>uint16_t</code> just can’t represent absence of a value. In C++ fields with default of <code>nothing</code> always map to <a href="../reference/cpp/classbond_1_1maybe.html"><code>bond::maybe&lt;T&gt;</code></a>. In C# reference types already have a way to represent absence of value: <code>null</code>. For these types specifying default of <code>nothing</code> doesn’t change the field type in the generated code. For C# value types such as <code>Int16</code>, generated code will use C# nullable type (e.g. <code>Int16?</code>).</p>
<p>The fact that setting default value of a field to <code>nothing</code> doesn’t affect the field’s schema type has an important consequence: the default value of the field doesn’t have serialized representation. What this means in practice depends on whether the field is <code>optional</code> or <code>required</code>. Optional fields set to <code>nothing</code> are usually omitted during serialization <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, just like for any other default values. <a href="#required-fields">Required fields</a>, by definition, can never be omitted. Since <code>nothing</code> has no serialized representation, an attempt to serialize an object with required fields set to <code>nothing</code> will result in a runtime exception. If a null value needs to be represented in the serialized form, then default of <code>nothing</code> is a wrong choice and a <a href="#nullable-types">nullable type</a> should be used instead.</p>
<h1 id="nullable-types">Nullable types</h1>
<p>For any type in Bond meta-schema <code>nullable&lt;T&gt;</code> defines a nullable type. A nullable type can store all the same values as the its base type plus one additional value: <code>null</code>.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> Nullables
{
    <span class="dv">0</span>: nullable&lt;<span class="dt">bool</span>&gt;         b;
    <span class="dv">1</span>: list&lt;nullable&lt;string&gt;&gt; l;
}</code></pre></td></tr></table></div>
<p>Default value for a field of a nullable type is always implicitly set to <code>null</code>. Explicit default values for nullable fields are not supported.</p>
<p>In generated C++ code nullable types are represented by <a href="../reference/cpp/classbond_1_1nullable_3_01_t_00_01_allocator_00_01false_01_4.html"><code>nullable&lt;T&gt;</code></a> class template.</p>
<p>Since a nullable type must represent the additional value of <code>null</code>, its serialized representation necessarily incurs some overhead compared to the base type. Often it is more efficient to avoid using nullable type and instead designate one of normal values to handle the special case that otherwise would be represented by <code>null</code>. For example <em>empty</em> is usually a good choice for string and container types and 0 for arithmetic types. Another option that may sometimes be appropriate is setting default value of a field to <a href="#default-value-of-nothing"><code>nothing</code></a>.</p>
<p>The canonical scenario where a nullable type is the right choice is recursive structures. For example here’s how Bond <code>TypeDef</code> struct is defined:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> TypeDef
{
    <span class="co">// Type identifier</span>
    <span class="dv">0</span>: BondDataType id = BT_STRUCT;

    <span class="co">// Index of struct definition in SchemaDef.structs when id == BT_STRUCT</span>
    <span class="dv">1</span>: uint16 struct_def = <span class="dv">0</span>;

    <span class="co">// Type definition for:</span>
    <span class="co">//  list elements (id == BT_LIST),</span>
    <span class="co">//  set elements (id == BT_SET),</span>
    <span class="co">//  or mapped value (id == BT_MAP)</span>
    <span class="dv">2</span>: nullable&lt;TypeDef&gt; element;

    <span class="co">// Type definition for map key when id == BT_MAP</span>
    <span class="dv">3</span>: nullable&lt;TypeDef&gt; key;

    <span class="co">// True if the type is bonded&lt;T&gt;; used only when id == BT_STRUCT</span>
    <span class="dv">4</span>: <span class="dt">bool</span> bonded_type;
}</code></pre></td></tr></table></div>
<p><code>TypeDef</code> struct is used to represent type of a field in a Bond schema. If the type is a container such as list or map, the type definition becomes recursive. For example, a list type definition contains type of the list element which of course itself can be a container of elements of some other type, and so on, until recursion is terminated with a <code>null</code> value for the <code>element</code> and <code>key</code> fields.</p>
<h1 id="runtime-schema">Runtime schema</h1>
<p>Some generic applications may need to work with Bond schemas unknown at compile-time. In order to address such scenarios Bond defines a type <code>SchemaDef</code> to represent schemas at runtime. Applications can obtain an instance of <code>SchemaDef</code> for a particular type using the <code>GetRuntimeSchema</code> API:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// from type T</span>
<span class="kw">auto</span> schema = bond::GetRuntimeSchema&lt;Example&gt;();

<span class="co">// from an instance</span>
<span class="kw">auto</span> schema = bond::GetRuntimeSchema(obj);</code></pre></td></tr></table></div>
<p>The value returned by <code>GetRuntimeSchema</code> is of type <code>bond::RuntimeSchema</code>, which is a thin wrapper over <code>SchemaDef</code>. The runtime schema object returned by the API is always self contained, including the runtime schema definitions for all nested types (if any). Note that GetRuntimeSchema returns a static object and can’t be called during module initialization (e.g. from a constructor of a static object).</p>
<p><code>SchemaDef</code> is a Bond type, defined in <code>bond.bond</code>, and as such can be de/serialized like any other Bond type:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">Serialize(bond::GetRuntimeSchema&lt;Example&gt;(), writer);</code></pre></td></tr></table></div>
<p>A runtime schema is often used to describe the schema of a serialized payload, in particular when using an untagged <a href="#protocols">protocol</a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">bond::SimpleBinaryReader reader(dataPayload);
<span class="kw">auto</span> schema = boost::make_shared&lt;bond::SchemaDef&gt;();

Unmarshal(schemaPayload, *schema);
Deserialize(reader, obj, schema);</code></pre></td></tr></table></div>
<p>The Deserialize API in the above code snippet is a thin wrapper around the generic way to describe payload with a runtime schema: <code>bonded&lt;void&gt;</code>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">bond::bonded&lt;<span class="dt">void</span>&gt; data(reader, schema);</code></pre></td></tr></table></div>
<p>A <code>bonded&lt;void&gt;</code> object can be used like any <a href="#understanding-bondedt"><code>bonded&lt;T&gt;</code></a>, e.g. it can be serialized/transcoded:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">Serialize(data, writer);</code></pre></td></tr></table></div>
<p>When an application creates an instance of <code>SchemaDef</code> in order to use it with Bond APIs, it is strongly recommended to always dynamically allocate the object and wrap it in a <code>boost::shared_ptr</code>, like in the example above. There are some subtle cases when Bond may need to keep a reference to the schema beyond the scope where it was created, and using a <code>shared_ptr</code> provides a safe and efficient way to achieve this. In order to encourage this, the <code>bond::RuntimeSchema</code> wrapper used by many Bond APIs is implicitly constructable from <code>boost::shared_ptr&lt;SchemaDef&gt;</code> but only explicitly from <code>const SchemaDef&amp;</code>.</p>
<p>A serialized representation of <code>SchemaDef</code> can be also obtained directly from a schema definition IDL file using <a href="compiler.html#runtime-schema">bond compiler</a>.</p>
<p>See example: <code>examples/cpp/core/runtime_schema</code>.</p>
<h1 id="compile-time-schema">Compile-time schema</h1>
<p>Bond generated C++ classes define a nested struct called <code>Schema</code> which describes the type’s schema. It is called compile-time schema because it supports reflection on the schema during C++ compilation, enabling various meta-programming techniques. The struct <code>Schema</code> has the following members:</p>
<ul>
<li><p><code>base</code></p>
<p>A typedef which is defined to either <code>bond::no_base</code> or the compile-time schema of the base schema.</p></li>
<li><p><code>metadata</code></p>
<p>A static data member of type <code>bond::Metadata</code> (defined in <code>bond::bond</code>). Describes schema’s metadata, such a name and optional attributes.</p></li>
<li><p><code>var</code></p>
<p>A struct with a typedef member for each schema field. The typedefs have the same name as the fields, e.g. <code>Example::Schema::var::m_example</code> represents a field <code>m_example</code> of class <code>Example</code>. The typedefs are defined to instances of <a href="../reference/cpp/structbond_1_1reflection_1_1_field_template.html"><code>bond::reflection::FieldTemplate</code></a> template.</p></li>
<li><p><code>fields</code></p>
<p>A <code>boost::mpl::list</code> of the fields. The elements of the list are typedef memebers of the <code>var</code> struct described above.</p></li>
</ul>
<p>Compile-time schema can also be defined in a non-intrusive way, e.g. for classes that can’t be modified, by specializing <code>schema</code> meta-function:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Enable = <span class="dt">void</span>&gt; <span class="kw">struct</span>
schema;</code></pre></td></tr></table></div>
<p>For an example see the compile-time schema definition for <code>std::tuple&lt;T...&gt;</code> in <code>bond/core/tuple.h</code>.</p>
<p>Code examples:</p>
<ul>
<li><code>examples/cpp/core/compile_time_schema</code></li>
<li><code>examples/cpp/core/polymorphic_container_visitor</code></li>
</ul>
<h1 id="understanding-bondedt">Understanding <code>bonded&lt;T&gt;</code></h1>
<p>The generic type <code>bonded&lt;T&gt;</code> is a simple yet powerful abstraction which is a fundamental part of Bond APIs and enables such usage scenarios as lazy deserialization, protocol transcoding, pass-through and polymorphism.</p>
<p>Fundamentally, <code>bonded&lt;T&gt;</code> is used to represents a struct data, but it is much more versatile than a simple struct instance. Before we explore its capabilities, let’s first look at C++ declaration of <a href="../reference/cpp/classbond_1_1bonded.html"><code>bonded</code> class</a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader = ProtocolReader&lt;T, InputBuffer&gt;&gt;
<span class="kw">class</span> bonded;</code></pre></td></tr></table></div>
<p>The class template has two parameters. The first one, <code>T</code>, represents schema (or type) of the data. Usually it is a struct defined via Bond <a href="compiler.html#idl-syntax">IDL</a> but it can also be <code>void</code> (see <a href="../reference/cpp/classbond_1_1bonded_3_01void_00_01_reader_01_4.html"><code>bonded&lt;void&gt;</code></a>) if we want to work with data for which schema is not known at compile-time. The second parameter, <code>Reader</code>, specifies representation of the data. The default, <code>ProtocolReader</code> is a variant type which can hold data serialized using any of the Bond protocols, or an instance of struct <code>T</code>.</p>
<p>The <code>bonded</code> class defines several constructors which allow creation of <code>bonded</code> objects from following inputs:</p>
<ul>
<li>Instance of <code>T</code> or a type derived from <code>T</code> <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></li>
</ul>
<!-- -->
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">using</span> bond::bonded;

MyStruct obj;

<span class="co">// Copy obj by value</span>
bonded&lt;MyStruct&gt; b1(obj);

<span class="co">// Store reference to obj</span>
bonded&lt;MyStruct&gt; b2(boost::ref(obj));

<span class="co">// Store shared_ptr to object</span>
<span class="kw">auto</span> ptr = boost::make_shared&lt;MyStruct&gt;();
bonded&lt;MyStruct&gt; b3(ptr);</code></pre></td></tr></table></div>
<ul>
<li>Serialized payload</li>
</ul>
<!-- -->
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">bond::CompactBinaryReader&lt;bond::InputBuffer&gt; reader(payload);

bonded&lt;MyStruct&gt; b4(reader);

bonded&lt;<span class="dt">void</span>&gt; b5(reader, schema);</code></pre></td></tr></table></div>
<ul>
<li>Compatible instance of <code>bonded</code></li>
</ul>
<!-- -->
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// Implicit up-casting</span>
bonded&lt;MyStructBase&gt; b6(b4);

<span class="co">// Explicit down-casting</span>
bonded&lt;MyStruct&gt; b7(b6);

<span class="co">// Explicit cast to bonded&lt;void&gt;</span>
bonded&lt;<span class="dt">void</span>&gt; b8(b7);

<span class="co">// Explicit cast from bonded&lt;void&gt;</span>
bonded&lt;MyStruct&gt; b9(b8);</code></pre></td></tr></table></div>
<p>APIs associated with <code>bonded&lt;T&gt;</code> are very simple. Given an instance of <code>bonded&lt;T&gt;</code> we can essentially perform two operations on the contained data:</p>
<ul>
<li>Deserialize an object from the data</li>
<li>Serialize the data using a protocol writer</li>
</ul>
<p>Versatility of <code>bonded&lt;T&gt;</code> comes from how these two operations apply to various kinds of data.</p>
<h2 id="lazy-deserialization">Lazy deserialization</h2>
<p>Because <code>bonded&lt;T&gt;</code> can store (or more accurately, refer to) data representing a serialized struct, it can be used to de facto delay deserialization of some parts of payload:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> Example
{
    <span class="dv">0</span>: Always            m_always;
    <span class="dv">1</span>: bonded&lt;Sometimes&gt; m_sometimes;
}</code></pre></td></tr></table></div>
<p>The schema defined above contains two nested fields. When an object of type <code>Example</code> is deserialized, the field <code>m_always</code> will be fully instantiated and deserialized, but field <code>m_sometimes</code>, which is declared as <code>bonded&lt;Sometimes&gt;</code>, will be merely initialized with a reference to its serialized representation <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">Example example;

Deserialize(reader, example);

<span class="co">// Deserialize m_sometimes only when needed</span>
<span class="kw">if</span> (needSometimes)
{
    Sometimes sometimes;

    example.m_sometimes.Deserialize(sometimes);
}</code></pre></td></tr></table></div>
<h2 id="protocol-transcoding">Protocol transcoding</h2>
<p>If <code>bonded&lt;T&gt;</code> contains data representing a serialized struct, what does it mean to serialize it? The answer to this questions is the key to understanding the power and versatility of <code>bonded&lt;T&gt;</code>. When serializing a <code>bonded&lt;T&gt;</code> object, Bond will iterate through the serialized data, decode each field and write it to target protocol writer <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. What’s more, if the source data is encoded using a tagged protocol (e.g. Compact Binary) Bond doesn’t depend on definition of struct <code>T</code> to know what fields the payload contains. The payload is self-described and Bond is able to preserve all fields, even those that are not part of struct <code>T</code> (e.g. because the payload was created using a newer version of the schema). In fact <code>bonded&lt;T&gt;</code> can be serialized <em>even</em> if definition of type <code>T</code> is not known!</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// Declare Unknown; actual definition is not needed</span>
<span class="kw">struct</span> Unknown;

<span class="co">// Transcode data from Compact Binary to JSON</span>
bond::CompactBinary&lt;bond::InputBuffer&gt; reader(data);
bond::bonded&lt;Unknown&gt; payload(reader);

bond::OutputBuffer json;
bond::SimpleJsonWriter&lt;bond::OutputBuffer&gt; writer(json);

Serialize(payload, writer);</code></pre></td></tr></table></div>
<p>The sample code above would preserve all the fields from the source data, however it would not preserve the field names, producing JSON output looking something like this:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">{
    <span class="st">&quot;10&quot;</span>: <span class="st">&quot;Sample Konfabulator Widget&quot;</span>,
    <span class="st">&quot;30&quot;</span>: <span class="dv">500</span>,
    <span class="st">&quot;40&quot;</span>: <span class="dv">500</span>
}</code></pre></td></tr></table></div>
<p>The output is sufficient to deserialize the object using Bond, but it is not particularly human-readable. If we wanted to preserve fields names in JSON output, we would need to specify the payload schema, by using either <code>bonded</code> of a defined Bond struct rather than <code>Unknown</code>, or <code>bonded&lt;void&gt;</code> with a schema provided at runtime.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// Transcode data from Compact Binary to JSON using runtime schema</span>
bond::CompactBinary&lt;bond::InputBuffer&gt; reader(data);
bond::bonded&lt;<span class="dt">void</span>&gt; payload(reader, schema);

bond::OutputBuffer json;
bond::SimpleJsonWriter&lt;bond::OutputBuffer&gt; writer(json);

Serialize(payload, writer);</code></pre></td></tr></table></div>
<p>The <code>schema</code> object in the example above is an instance of <a href="#runtime-schema"><code>bond::SchemaDef</code></a>. With full schema information transcoded JSON output will be more human-friendly:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">{
    <span class="st">&quot;title&quot;</span>: <span class="st">&quot;Sample Konfabulator Widget&quot;</span>,
    <span class="st">&quot;width&quot;</span>: <span class="dv">500</span>,
    <span class="st">&quot;height&quot;</span>: <span class="dv">500</span>
}</code></pre></td></tr></table></div>
<p>See also: <code>examples/cpp/core/protocol_transcoding</code></p>
<h2 id="pass-through">Pass-through</h2>
<p>The fact that <code>bonded&lt;T&gt;</code> preserves unknown fields is very useful when building service pipelines. Intermediary nodes often need to pass data through with full fidelity. At the same time, it is desirable that every schema change doesn’t necessitate redeployment of all the nodes in a pipeline. Using <code>bonded&lt;T&gt;</code> for pass-through is often the right solution.</p>
<p>As an example let’s imagine a simple aggregator which receives responses from upstream services and aggregates top results.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> Response;

<span class="kw">struct</span> Upstream
{
    <span class="dv">0</span>: bonded&lt;Response&gt; response;
    <span class="dv">1</span>: <span class="dt">float</span> ranking;
}

<span class="kw">struct</span> Aggregated
{
    <span class="dv">0</span>: list&lt;bonded&lt;Response&gt;&gt; responses;
}</code></pre></td></tr></table></div>
<p>Using <code>bonded&lt;Response&gt;</code> allows the intermediary to aggregate responses, preserving their full content, even though schema of <code>Response</code> is not known when the aggregator is built, and thus it doesn’t need to be rebuilt or redeployed when schema of <code>Response</code> changes.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="dt">void</span> ProcessResponse(<span class="dt">const</span> Upstream&amp; upstream)
{
    <span class="kw">if</span> (upstream.ranking &gt; threshold)
    {
        m_aggregated.responses.push_back(upstream.response);
    }
}</code></pre></td></tr></table></div>
<h2 id="polymorphism">Polymorphism</h2>
<p>Bond support for polymorphism is built around the capability of <code>bonded&lt;T&gt;</code> to contain serialized struct data not limited to just fields of struct <code>T</code>. In particular <code>bonded&lt;Base&gt;</code> can contain serialized data for some struct <code>Derived</code> which inherits from <code>Base</code>. Together with the ability to down-cast <code>bonded&lt;Base&gt;</code> to <code>bonded&lt;Dervied&gt;</code>, this enables use of Bond schemas supporting serialization of polymorphic objects.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">enum</span> Kind
{
    rectangle,
    circle,
    none
}

<span class="kw">struct</span> Shape
{
    <span class="dv">0</span>: Kind kind = none;
}

<span class="kw">struct</span> Rectangle: Shape
{
    <span class="dv">0</span>: int32 width;
    <span class="dv">1</span>: int32 height;
}

<span class="kw">struct</span> Circle : Shape
{
    <span class="dv">0</span>: int32 radius;
}

<span class="kw">struct</span> Example
{
    <span class="dv">0</span>: list&lt;bonded&lt;Shape&gt;&gt; shapes;
}</code></pre></td></tr></table></div>
<p>For details on implementing polymorphism see the following examples:</p>
<ul>
<li><code>examples/cpp/core/polymorphic_container</code></li>
<li><code>examples/cpp/core/polymorphic_container_visitor</code></li>
</ul>
<h2 id="bonus-explainer-parallels-between-bondedt-and-c-pointers">Bonus explainer: parallels between <code>bonded&lt;T&gt;</code> and C++ pointers</h2>
<p>The rules of casting and slicing that apply to <code>bonded&lt;T&gt;</code> are by design very similar to the standard C++ rules for pointers:</p>
<table>
<colgroup>
<col width="28%"></col>
<col width="34%"></col>
<col width="36%"></col>
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>bonded&lt;T&gt;</th>
<th>C++ pointer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Slicing to base</p></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">bonded&lt;Derived&gt; b;
Base obj;
b.Deserialize(obj);</code></pre></div></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Derived* p;
Base obj;
obj = *p;</code></pre></div></td>
</tr>
<tr class="even">
<td><p>Assigning to base part</p></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">bonded&lt;Base&gt; b;
Derived obj;
b.Deserialize(obj);</code></pre></div></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Base* p;
Derived obj;
<span class="kw">static_cast</span>&lt;Base&amp;&gt;(obj) = *p;</code></pre></div></td>
</tr>
<tr class="odd">
<td><p>Implicit up-casting</p></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(bonded&lt;Base&gt;);
bonded&lt;Derived&gt; b;
foo(b);</code></pre></div></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(Base*)
Derived* p;
foo(p);</code></pre></div></td>
</tr>
<tr class="even">
<td><p>Explicit down-casting</p></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">bonded&lt;Base&gt; b;
Derived obj;
bonded&lt;Derived&gt;(b)
    .Deserialize(obj);</code></pre></div></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Base* p;
Derived obj;
obj = *<span class="kw">static_cast</span>&lt;Derived*&gt;(p);</code></pre></div></td>
</tr>
<tr class="odd">
<td><p>Implicit cast to void</p></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(bonded&lt;<span class="dt">void</span>&gt;);
bonded&lt;Bar&gt; b;
foo(b);</code></pre></div></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> foo(<span class="dt">void</span>*);
Bar* p;
foo(p);</code></pre></div></td>
</tr>
<tr class="even">
<td><p>Explicit cast from void</p></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">bonded&lt;<span class="dt">void</span>&gt; b(data, schema);
bonded&lt;Bar&gt; bb;
bb = bonded&lt;Bar&gt;(b);</code></pre></div></td>
<td><div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span>* p = &amp;obj
Bar* pp;
pp = <span class="kw">static_cast</span>&lt;Bar*&gt;(p);</code></pre></div></td>
</tr>
</tbody>
</table>
<h1 id="merge">Merge</h1>
<p>An important feature of Bond is the ability to preserve unknown fields (<a href="#pass-through">Pass-through</a>), or even whole parts of the inheritance hierarchy (<a href="#polymorphism">Polymorphism</a>), when transcoding or forwarding serialized Bond payloads. The merge feature builds on these capabilities by allowing modifications to the known part of a structure and merging them with any unknown parts present in the payload.</p>
<p>The <code>Merge</code> API takes as input an instance of a Bond object and a serialized payload and writes the merged result to the specified protocol writer:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader, <span class="kw">typename</span> Writer&gt;
<span class="dt">void</span> Merge(<span class="dt">const</span> T&amp; obj, Reader input, Writer&amp; output);</code></pre></td></tr></table></div>
<p>The <code>Reader</code> and <code>Writer</code> can be for different protocols (in other words merging can transcode payload at the same time). The type <code>T</code> of the object is usually somehow related to the schema of the input payload (e.g. a different version of the schema or its base). In the typical usage scenario, the object is first deserialized from the payload, and then modified and merged with original payload.</p>
<p>The <code>Merge</code> API is a thin wrapper around the <code>Merger</code> transform which can be applied to a <a href="#understanding-bondedt"><code>bonded&lt;T&gt;</code></a> in order to merge its payload with an instance of T, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">typedef</span> bond::CompactBinaryWriter&lt;bond::OutputBuffer&gt; Writer;
T obj;
bond::bonded&lt;T&gt; payload;
<span class="co">// ...</span>
Writer output(buffer);
Apply(bond::Merger&lt;T, Writer&gt;(obj, output), payload);</code></pre></td></tr></table></div>
<p>For fields that are present in the object’s schema, the value in the object is serialized, otherwise the value for the unknown field in the payload is preserved. Merge works recursively, merging bases and any nested structures, including structures that are elements of a container. When merging containers containing structures, lists and vectors must have the same number of elements and maps must have the same set of keys in both the object and in the payload, otherwise Merge throws an exception. Containers with non-struct types as elements are treated like regular fields.</p>
<p>Fields and containers of type <code>bonded&lt;T&gt;</code> are not merged and instead the value from the object is written to the output. This allows applications to selectively merge individual <code>bonded&lt;T&gt;</code> fields or elements, enabling, for example, merging of containers when elements have been added or removed.</p>
<p>The helper method Merge supports the common scenario where the result of merge is put back as payload of <code>bonded&lt;T&gt;</code>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">template</span> &lt;<span class="kw">typename</span> X&gt;
<span class="dt">void</span> bonded&lt;T&gt;::Merge(<span class="dt">const</span> X&amp; var);</code></pre></td></tr></table></div>
<p>See example: <code>examples/cpp/core/merge</code>.</p>
<h1 id="required-fields">Required fields</h1>
<p>By default, struct fields in Bond schemas are considered optional. This means that during deserialization, if the payload doesn’t contain a field, Bond will just use the field’s default value specified in the schema. Consequently, during serialization optional fields which are set to their default value <em>can</em> be omitted, resulting in a more compact payload. This behavior is fundamental to enabling forward and backward compatibility between different schema versions. As long as fields are optional, they can be freely added and removed, without breaking the ability of the old code to deserialize the new data and vice versa. In distributed systems, where we usually can’t depend on deployment order, this two-way compatibility is a critical feature. This is why optional fields are the implicit default in Bond, and why avoiding required fields is generally considered a good rule of thumb.</p>
<p>Required fields can be declared using the following syntax.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> Example
{
    <span class="dv">0</span>: required int32 field;
}</code></pre></td></tr></table></div>
<p>Required fields <em>must</em> be present in the payload during deserialization (otherwise an exception is thrown) and consequently they are always written to the payload during serialization.</p>
<p>When should you use required fields? One way to think about this is that required fields are a way to <em>explicitly break</em> schema compatibility. Essentially, a schema with required field(s) means: a consumer using this schema is incompatible with any version of the schema, past or future, that doesn’t have the required field(s). In cases when the semantics of a field are such that the schema doesn’t make sense without it, declaring the field as required might be the right thing to do.</p>
<p>Specifying a field as required doesn’t mean that it can <em>never</em> be removed from the schema, but it does mean that <em>all</em> existing consumers using the schema will have to be updated first. In order to enable adding/removing required fields (or converting optional fields to required and vice versa), Bond supports an intermediary state for fields called <code>required_optional</code>. Fields that are marked as <code>required_optional</code> behave like required fields during serialization (i.e. their value is always included in the payload) and like optional fields during deserialization (i.e. if the field is not in the payload, Bond will use the default value). This allows non-breaking, deployment-order-independent schema changes that involve <code>required</code> fields.</p>
<p><strong>required &lt;—-&gt; required_optional &lt;—-&gt; optional</strong></p>
<p>Changes involving <code>required</code> fields take two steps. First the schema is updated to use a <code>required_optional</code> field (i.e. a new <code>required_optional</code> field is added or an existing <code>required</code> or <code>optional</code> field is converted to <code>required_optional</code>). These changes are non-breaking and can be deployed in any order. Once all programs using the updated schema are deployed, in the second step the <code>required_optional</code> field can be removed or converted to <code>required</code> or <code>optional</code> as desired. Again these changes are non-breaking.</p>
<h1 id="tuples">Tuples</h1>
<p>Bond can de/serialize instances of std::tuple&lt;T…&gt; as if they were regular Bond-defined structs. For example the following tuple instance:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">std::tuple&lt;std::string, <span class="dt">double</span>, std::vector&lt;<span class="dt">uint32_t</span>&gt;&gt;</code></pre></td></tr></table></div>
<p>is equivalent to this Bond schema:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> tuple
{
    <span class="dv">0</span>: string item0;
    <span class="dv">1</span>: <span class="dt">double</span> item1;
    <span class="dv">2</span>: vector&lt;uint32&gt; item2;
}</code></pre></td></tr></table></div>
<p>Field ordinals used for Bond serialization are the same as tuple item identifiers used with std::get<N> function. Field names are <code>item</code><em>N</em> where is <em>N</em> is the item identifier. The schema/struct name for a tuple instance is <code>tuple&lt;</code><em>parameters</em><code>&gt;</code>.</p>
<p>Since field ordinals are implicitly assigned based on the order in which items are defined, tuples don’t offer the same versioning flexibility as explicitly defined Bond schemas. In particular, adding or removing any tuple item other than the last is a breaking change because it offsets ordinals of all subsequent items.</p>
<p>Tuple instances can be used with all Bond APIs that accept regular Bond defined structs, e.g:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">auto</span> obj = std::tuple&lt;string, <span class="dt">double</span>&gt;;

Serialize(obj, writer);
Deserialize(reader, obj);
<span class="kw">auto</span> schema = bond::GetRuntimeSchema(obj);</code></pre></td></tr></table></div>
<p>Bond provides helper functions <code>Pack</code> and <code>Unpack</code> which can be used respectively to create/serialize a tuple from several values and deserialize struct fields into several variables.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">std::string str;
Pack(writer, str, <span class="dv">10</span>);

<span class="dt">int</span> n;
std::string str2;
Unpack(reader, str2, n);</code></pre></td></tr></table></div>
<p>If the payload contains more fields than variables provided to <code>Unpack</code> the tail fields are ignored. The special object <code>std::ignore</code> can be passed as an argument to <code>Pack</code> and <code>Unpack</code> in order to ignore field(s) at particular position(s). For example:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">Pack(writer, std::ignore, <span class="dv">10</span>);</code></pre></td></tr></table></div>
<p>will serialize a struct/tuple containing one field with ordinal 1 and type <code>int</code>. Similarly:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">Unpack(reader, std::ignore, n);</code></pre></td></tr></table></div>
<p>will ignore the field with ordinal 0, if any, and deserialize the field with ordinal 1 into the variable <code>n</code>.</p>
<p>Examples:</p>
<ul>
<li><code>examples/native/core/trace</code></li>
<li><code>examples/native/core/variadic</code></li>
</ul>
<h1 id="transforms">Transforms</h1>
<p>Bond transform are a powerful mechanism which enables writing generic, schema-independent, type-safe and high performance code operating on instances of Bond generated classes and their serialized representation. As transforms are flexible and have good performance characteristics, the core APIs like <code>Serialize</code> and <code>Deserialize</code> are in fact implemented as applications of transforms.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="co">// Serialize and Deserialize APIs as defined in bond.h</span>

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Writer&gt;
<span class="kw">inline</span> <span class="dt">void</span> Serialize(<span class="dt">const</span> T&amp; obj, Writer&amp; output)
{
    Apply(Serializer&lt;Writer&gt;(output), obj);
}

<span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
<span class="kw">inline</span> <span class="dt">void</span> Deserialize(Reader input, T&amp; obj)
{
    Apply(To&lt;T&gt;(obj), bonded&lt;T, Reader&amp;&gt;(input));
}</code></pre></td></tr></table></div>
<p>Transforms are an instance of the visitor pattern. A transform class implements methods which are called by a Bond parser for the fields of a Bond type instance or its serialized representation. The name <em>transform</em> comes from the fact that they usually perform transformation of Bond objects or payloads. For example the <code>Serializer</code> transform can be applied to an object and output its serialized representation, or it may be applied to a payload encoded in one protocol and transcode it into another protocol.</p>
<p>Transforms are applied using the <code>bond::Apply</code> API. The first argument to <code>Apply</code> is always a const reference to an instance of transform class, and the second argument is an object the transform should be applied to. There are essentially three overloads of <code>Apply</code> API <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> Transform, <span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
<span class="dt">bool</span> Apply(<span class="dt">const</span> Transform&amp; transform, <span class="dt">const</span> bonded&lt;T, Reader&gt;&amp; bonded);

<span class="kw">template</span> &lt;<span class="kw">typename</span> Transform, <span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
<span class="dt">void</span> Apply(<span class="dt">const</span> Transform&amp; transform, <span class="dt">const</span> value&lt;T, Reader&gt;&amp; value);

<span class="kw">template</span> &lt;<span class="kw">typename</span> Transform, <span class="kw">typename</span> T&gt;
<span class="dt">bool</span> Apply(<span class="dt">const</span> Transform&amp; transform, T&amp; value);</code></pre></td></tr></table></div>
<p>A transform class must inherit from one of the following classes:</p>
<ul>
<li><a href="../reference/cpp/structbond_1_1_serializing_transform.html"><code>bond::SerializingTransform</code></a></li>
<li><a href="../reference/cpp/structbond_1_1_deserializing_transform.html"><code>bond::DeserializingTransform</code></a></li>
<li><a href="../reference/cpp/structbond_1_1_modifying_transform.html"><code>bond::ModifyingTransform</code></a></li>
</ul>
<p>The base indicates the type of transformation performed by the class, and what kind of object it can be applied to. A serializing transform can be applied to an object or a serialized payload and usually outputs serialized payload. A deserializing transform can only be applied to a serialized payload. A modifying transform can only be applied to a non-const object and usually modifies the object.</p>
<h2 id="transform-concept">Transform concept</h2>
<p>A transform class has to implement the following concept:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> Transform
{
    <span class="co">// All transforms</span>
    <span class="dt">void</span> Begin(<span class="dt">const</span> bond::Metadata&amp; metadata) <span class="dt">const</span>;

    <span class="dt">void</span> End() <span class="dt">const</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="dt">bool</span> Base(<span class="dt">const</span> T&amp; value) <span class="dt">const</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="dt">bool</span> Field(<span class="dt">uint16_t</span> id, <span class="dt">const</span> bond::Metadata&amp; metadata, T&amp; value) <span class="dt">const</span>;

    <span class="co">// Only serializing and deserializing transforms</span>
    <span class="dt">void</span> UnknownEnd() <span class="dt">const</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="dt">bool</span> UnknownField(<span class="dt">uint16_t</span> id, T&amp; value) <span class="dt">const</span>;

    <span class="dt">bool</span> OmittedField(<span class="dt">uint16_t</span> id, <span class="dt">const</span> bond::Metadata&amp; metadata, bond::BondDataType type) <span class="dt">const</span>;

    <span class="co">// Only serializing transforms</span>
    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="dt">void</span> Container(<span class="dt">const</span> T&amp; element, <span class="dt">uint32_t</span> size) <span class="dt">const</span>;

    <span class="kw">template</span> &lt;<span class="kw">typename</span> Key, <span class="kw">typename</span> T&gt;
    <span class="dt">void</span> Container(<span class="dt">const</span> Key&amp; key, <span class="dt">const</span> T&amp; value, <span class="dt">uint32_t</span> size) <span class="dt">const</span>;
};</code></pre></td></tr></table></div>
<p>The type <code>T</code> of the values visited by a transform depends on what the transform is applied to. If it is applied to an instance of a Bond type, the visited values will be references to the object’s fields and/or its base object (if any). If a transform is applied to a serialized payload, the visited values will represent the serialized fields, elements of a container and/or base (if any). The serialized data is represented by one of two types: <code>bond::bonded&lt;T,  Reader&gt;</code> or <code>bond::value&lt;T, Reader&gt;</code>. The former represents a serialized Bond object and the latter a serialized value of a basic type or a container.</p>
<p>A transform can generally do one of two things with the serialized values:</p>
<ol style="list-style-type: decimal">
<li>Deserialize using the Deserialize method</li>
</ol>
<!-- -->
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, <span class="kw">typename</span> Reader&gt;
<span class="kw">typename</span> boost::enable_if&lt;bond::is_basic_type&lt;T&gt;&gt;::type
Field(<span class="dt">uint16_t</span>, <span class="dt">const</span> bond::Metadata&amp;, <span class="dt">const</span> bond::value&lt;T, Reader&gt;&amp; value) <span class="dt">const</span>
{
    T x;
    value.Deserialize(x);
    <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre></td></tr></table></div>
<ol start="2" style="list-style-type: decimal">
<li>Recursively apply the transform</li>
</ol>
<!-- -->
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">bool</span> Base(<span class="dt">const</span> T&amp; value) <span class="dt">const</span>
{
    <span class="kw">return</span> Apply(MyTransform(), value);
}</code></pre></td></tr></table></div>
<p>Recursive application of transforms is a key technique which enables transformations of arbitrary complex/nested schemas/containers. By creating and applying an new instance of its class, a transform class can easily implement management of per-hierarchy-level state. For example a transform creating a text output such as XML, could store the indentation level in its data member and create a new instance with increased indentation to be applied to nested fields.</p>
<p>Transforms are a deep topic and by necessity this article only touches on the most basic concepts. Users writing their own custom transforms are encouraged to study the implementation of built in transforms in <a href="../reference/cpp/transforms_8h_source.html">transfroms.h</a>, in particular the <code>Serializer&lt;Writer&gt;</code> and <code>To&lt;T&gt;</code> transforms.</p>
<p>Code examples:</p>
<ul>
<li><code>examples/cpp/core/transform</code></li>
<li><code>examples/cpp/core/modifying_transform</code></li>
<li><code>examples/cpp/core/access_control</code></li>
</ul>
<h1 id="reflection">Reflection</h1>
<p>See <a href="#compile-time-schema">compile-time schema</a> and <a href="#transforms">transforms</a>.</p>
<h1 id="protocols">Protocols</h1>
<p>Bond protocols are pluggable, allowing application to choose the most appropriate encoding format. Bond supports three kinds of protocols:</p>
<ul>
<li><p>Tagged protocols</p>
<p>Tagged protocols interleave schema metadata within the payload. This makes the payload self-describing, allowing consumers to interpret it even without knowing the schema used by the producer.</p></li>
<li><p>Untagged protocols</p>
<p>Untagged protocols serialize only data and thus require that consumers know the payload schema via some out-of-band mechanism. Untagged protocols are often used in storage scenarios because they allow storing a <a href="#runtime-schema">schema</a> once (e.g. in a system table in a database) and thus eliminating metadata overhead from many records using the same schema.</p></li>
<li><p>DOM-based protocols</p>
<p>DOM-based protocol parse whole payload into an in-memory Data Object Model which then is queried during deserialization. Typically this kind of protocol is used to implement text based encoding such as JSON or XML.</p></li>
</ul>
<h2 id="compact-binary">Compact Binary</h2>
<p>A binary, tagged protocol using variable integer encoding and compact field header. A good choice, along with <a href="#fast-binary">Fast Binary</a>, for RPC scenarios.</p>
<p>Implemented in <a href="../reference/cpp/classbond_1_1_compact_binary_reader.html"><code>CompactBinaryReader</code></a> and <a href="../reference/cpp/classbond_1_1_compact_binary_writer.html"><code>CompactBinaryWriter</code></a> classes.</p>
<p>Version 2 of Compact Binary adds length prefix for structs. This enables deserialization of <a href="#understanding-bondedt"><code>bonded&lt;T&gt;</code></a> and skipping of unknown struct fields in constant time. The trade-off is double pass encoding, resulting in up to 30% slower serialization performance.</p>
<p>See also <a href="../reference/cpp/compact__binary_8h_source.html">Compact Binary encoding reference</a>.</p>
<h2 id="fast-binary">Fast Binary</h2>
<p>A binary, tagged protocol similar to <a href="#compact-binary">Compact Binary</a> but optimized for deserialization speed rather than payload compactness.</p>
<p>Implemented in <a href="../reference/cpp/classbond_1_1_fast_binary_reader.html"><code>FastBinaryReader</code></a> and <a href="../reference/cpp/classbond_1_1_fast_binary_writer.html"><code>FastBinaryWriter</code></a> classes.</p>
<p>See also <a href="../reference/cpp/fast__binary_8h_source.html">Fast Binary encoding reference</a>.</p>
<h2 id="simple-binary">Simple Binary</h2>
<p>A binary, untagged protocol which is a good choice for storage scenarios as it offers potential for big saving on payload size. Because Simple is an untagged protocol, it requires that the payload schema is available during deserialization. In typical storage scenario application would store <a href="#runtime-schema">runtime schema</a> and use it during deserialization with <a href="../reference/cpp/classbond_1_1bonded_3_01void_00_01_reader_01_4.html"><code>bonded&lt;void&gt;</code></a>. In some specific scenarios when it can be assumed that producer and consumer have exactly the same schema, Simple Protocol can be used with compile-time schema, providing unparalleled deserialization performance. One example is marshaling objects between processes or between native and managed components.</p>
<p>Implemented in <a href="../reference/cpp/classbond_1_1_simple_binary_reader.html"><code>SimpleBinaryReader</code></a> and <a href="../reference/cpp/classbond_1_1_simple_binary_writer.html"><code>SimpleBinaryWriter</code></a> classes.</p>
<p>Version 2 of Simple Protocol uses variable integer encoding for string and container lengths, resulting in more compact payload without measurable performance impact.</p>
<p>See example: <code>examples/cpp/core/protocol_versions</code>.</p>
<h2 id="simple-json">Simple JSON</h2>
<p>The Simple JSON protocol is a simple JSON encoding implemented as a DOM protocol. The output is standard JSON and is a very good choice for interoperating with other systems or generating human readable payload.</p>
<p>Because the payload doesn’t include field ordinals, there are two caveats when used as a Bond serialization protocol:</p>
<ul>
<li>Transcoding from Simple JSON to binary Bond protocols is not supported (transcoding from a binary protocol to Simple JSON is supported if you have the schema).</li>
<li>Field matching is done by field name rather than ordinal. The implication is that renaming a field (which is considered a bad practice anyways) is a breaking schema change for Simple JSON.</li>
</ul>
<p>Simple JSON also flattens the inheritance hierarchy which may lead to name conflicts between fields of base and derived Bond structs. It is possible to resolve such conflicts without the need to actually rename the fields by annotating fields with <code>JsonName</code> attribute, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">struct</span> Base
{
    <span class="dv">0</span>: string foo;
}

<span class="kw">struct</span> Derived : Base
{
    [JsonName(<span class="st">&quot;DerivedFoo&quot;</span>)]
    <span class="dv">0</span>: string foo;
}</code></pre></td></tr></table></div>
<p>Note that Simple JSON is not designed to be able to read arbitrary JSON objects. Simple JSON has its own way of encoding Bond objects in JSON that differs from how other libraries would encode the same object. When interoperating with other JSON libraries, be aware of these differences:</p>
<ul>
<li>maps are encoded as arrays of key/value pairs not as sub-objects</li>
<li>the inheritance hierarchy is flattened</li>
<li>nulls are expressed as empty arrays</li>
<li>enums are encoded via their numeric value, not their symbolic names</li>
</ul>
<p>Implemented in <a href="../reference/cpp/classbond_1_1_simple_json_reader.html"><code>SimpleJsonReader</code></a> and <a href="../reference/cpp/classbond_1_1_simple_json_writer.html"><code>SimpleJsonWriter</code></a> classes.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cpp/core/simple_json</code></li>
</ul>
<h1 id="custom-type-mappings">Custom type mappings</h1>
<p>Bond codegen provides a simple extensibility mechanism allowing use of custom C++ types to represent types in a Bond schema. One common scenario is replacing the default STL containers with a different implementation that is semantically identical, e.g. <code>std::unordered_map</code> instead of <code>std::map</code>. Custom type mappings can be also used to introduce completely new types which can be serialized to one of the built-in Bond schema types. For example time could be represented using the <code>boost::posix_time::ptime</code> class and serialized as <code>int64</code>.</p>
<p>Defining a custom type mapping involves three steps:</p>
<ul>
<li>Define a <a href="compiler.html#type-aliases">type alias</a> in the schema.</li>
<li>Specify during codegen a C++ type to represent the alias.</li>
<li>Implement an appropriate concept for the custom C++ type.</li>
</ul>
<h2 id="codegen-parameters">Codegen parameters</h2>
<p>When generating code for a schema that uses <a href="compiler.html#type-aliases">type aliases</a>, the user can specify a custom type to represent each alias in the generated code:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">gbc c++ --<span class="kw">using</span>=<span class="st">&quot;time=boost::posix_time::ptime&quot;</span> time.bond</code></pre></td></tr></table></div>
<p>The value of the <code>--using</code> parameter is a custom alias mapping in the following format:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">alias-name=generated-type-name</code></pre></td></tr></table></div>
<p>Generated code using custom types usually has to include a header file with appropriate declarations. The <code>gbc</code> compiler supports the <code>--header</code> parameter for that purpose:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">gbc c++ --header=<span class="st">&quot;&lt;time_alias.h&gt;&quot;</span> --<span class="kw">using</span>=<span class="st">&quot;time=boost::posix_time::ptime&quot;</span> time.bond</code></pre></td></tr></table></div>
<p>The above command will add the following statement at the top of the generated header file <code>time_types.h</code>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="ot">#include &lt;time_alias.h&gt;</span></code></pre></td></tr></table></div>
<h2 id="container-concept">Container concept</h2>
<p>The custom container concept defined in <code>bond/core/container_interface.h</code> serves as an interface between a custom container type and Bond. The concept consists of compile-time meta-function (traits) that need to be specialized for the custom container type and overloaded free functions which implement the runtime interaction with the container instances. The concept forms a non-intrusive interface, which can be provided for any type without changes to its implementation.</p>
<p>The first step is to identify a type as an appropriate container by specializing one of the following traits:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
is_set_container
    : std::false_type {};

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
is_map_container
    : std::false_type {};

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
is_list_container
    : std::false_type {};</code></pre></td></tr></table></div>
<p>For example the following specialization would allow Bond to treat <code>std::array</code> as a list type:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T, std::size_t N&gt; <span class="kw">struct</span>
is_list_container&lt;std::array&lt;T, N&gt; &gt;
    : std::true_type {};</code></pre></td></tr></table></div>
<p>The second trait called <code>element_type</code> specifies the type of the container elements:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
element_type
{
    <span class="kw">typedef</span> <span class="kw">typename</span> T::value_type type;
};</code></pre></td></tr></table></div>
<p>The default implementation assumes a commonly used STL convention of using a nested <code>value_type</code> typedef and will likely work for many container implementations from libraries like Boost. For other containers the trait can specialized, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
element_type&lt;MyList&lt;T&gt; &gt;
{
    <span class="kw">typedef</span> T type;
};</code></pre></td></tr></table></div>
<p>The next part of the container concept consists of free functions exposing container size and operations to add and remove elements.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">uint32_t</span> container_size(<span class="dt">const</span> T&amp; container);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> resize_list(T&amp; list, <span class="dt">uint32_t</span> size);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> clear_set(T&amp; set);

<span class="kw">template</span> &lt;<span class="kw">typename</span> S, <span class="kw">typename</span> T&gt;
<span class="dt">void</span> set_insert(S&amp; set, <span class="dt">const</span> T&amp; item);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> clear_map(T&amp; map);

<span class="kw">template</span> &lt;<span class="kw">typename</span> M, <span class="kw">typename</span> K, <span class="kw">typename</span> T&gt;
T&amp; mapped_at(M&amp; map, <span class="dt">const</span> K&amp; key);</code></pre></td></tr></table></div>
<p>Note that unlike the traits which need to be specialized in the <code>bond</code> namespace, these function can be overloaded in the namespace of the container type.</p>
<p>The final part of the container concept are enumerators:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> enumerator
{
    <span class="kw">explicit</span> enumerator(T&amp; container);
    <span class="dt">bool</span> more() <span class="dt">const</span>;
    <span class="kw">typename</span> element_type&lt;T&gt;::type&amp; next();
};


<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> const_enumerator
{
    <span class="kw">explicit</span> const_enumerator(<span class="dt">const</span> T&amp; container);
    <span class="dt">bool</span> more() <span class="dt">const</span>;
    <span class="dt">const</span> <span class="kw">typename</span> element_type&lt;T&gt;::type&amp; next();
};</code></pre></td></tr></table></div>
<p>The <code>const_enumerator</code> must be implemented for any custom container while the <code>enumerator</code> is used only for lists. As the name indicates, the enumerators abstract iteration over elements of the container. The default implementation of <code>const_enumerator</code> illustrates well the simple semantics of the interface <a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> const_enumerator
{
<span class="kw">public</span>:
    <span class="kw">explicit</span> const_enumerator(<span class="dt">const</span> T&amp; container)
        : it(container.begin()),
          end(container.end())
    {}

    <span class="dt">bool</span> more() <span class="dt">const</span> 
    {
        <span class="kw">return</span> it != end;
    }

    <span class="kw">typename</span> T::const_reference 
    next()
    {
        <span class="kw">return</span> *(it++);
    }

<span class="kw">private</span>:
    <span class="kw">typename</span> T::const_iterator it, end;
};</code></pre></td></tr></table></div>
<ul>
<li><code>examples/cpp/core/container_of_pointers</code></li>
<li><code>examples/cpp/core/multiprecision</code></li>
<li><code>examples/cpp/core/static_array</code></li>
</ul>
<h2 id="string-concept">String concept</h2>
<p>The custom string concept defined in <code>bond/core/container_interface.h</code> serves as an interface between a custom string type and Bond.</p>
<p>Custom string types are identified by specializing the appropriate trait:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
is_string
    : std::false_type {};

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
is_wstring
    : std::false_type {};</code></pre></td></tr></table></div>
<p>For example the following specialization would allow Bond to treat <code>boost::string_ref</code> as a string type:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span>
is_string&lt;boost::string_ref&gt;
    : std::true_type {};</code></pre></td></tr></table></div>
<p>The operations on custom strings are exposed by overloading the following free functions:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> C, <span class="kw">typename</span> T&gt;
<span class="dt">const</span> C* string_data(<span class="dt">const</span> T&amp; str);

<span class="kw">template</span>&lt;<span class="kw">typename</span> C, <span class="kw">typename</span> T&gt;
C* string_data(T&amp; str);

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="dt">uint32_t</span> string_length(<span class="dt">const</span> T&amp; str);

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> resize_string(T&amp; str, <span class="dt">uint32_t</span> size);</code></pre></td></tr></table></div>
<ul>
<li><code>examples/cpp/core/string_ref</code></li>
</ul>
<h2 id="scalar-concept">Scalar concept</h2>
<p>The custom scalar type concept defined in <code>bond/core/scalar_interface.h</code> serves as an interface between Bond and a custom type aliasing a built-in scalar type.</p>
<p>The <code>aliased_type</code> trait is used to specify which built-in type is being aliased:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt; <span class="kw">struct</span>
aliased_type
{
    <span class="kw">typedef</span> <span class="dt">void</span> type;
};</code></pre></td></tr></table></div>
<p>For example the following specialization would tell Bond to treat <code>boost::posix_time::ptime</code> as if it were an alias of <code>int64</code>.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;&gt; <span class="kw">struct</span>
aliased_type&lt;boost::posix_time::ptime&gt;
{
    <span class="kw">typedef</span> <span class="dt">int64_t</span> type;
};</code></pre></td></tr></table></div>
<p>Conversions to/from a custom type and its aliased type are implemented as a pair of free function:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="dt">void</span> set_aliased_value(T&amp; var, <span class="kw">typename</span> aliased_type&lt;T&gt;::type value);

<span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
<span class="kw">typename</span> aliased_type&lt;T&gt;::type get_aliased_value(<span class="dt">const</span> T&amp; value);</code></pre></td></tr></table></div>
<ul>
<li><code>examples/cpp/core/time_alias</code></li>
</ul>
<h1 id="custom-allocators">Custom allocators</h1>
<p>The Bond compiler flag <code>--allocator</code> can be used to generate schema structs such that all containers are declared to use a custom allocator type:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">gbc c++ --allocator=my::arena example.bond</code></pre></td></tr></table></div>
<p>If the allocator is stateful, the application can pass a pointer to an allocator instance to the struct constructor. The allocator will then be passed to constructors of all container fields and nested structs. During deserialization Bond will also make sure that any container elements are constructed using the same allocator.</p>
<p>The generated structs can use any allocator which implements the C++ Standard Library allocator concept.</p>
<p>Bond APIs which allocate memory also allow use of custom allocators. In particular <code>bond::OutputMemoryStream</code>, which can be used as output stream for Bond serialization, can allocate the memory blobs for serialized payload with a user specified allocator.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">typedef</span> bond::OutputMemoryStream&lt;my::arena&gt; Output;

my::arena arena;
Output output(arena);
bond::CompactBinaryWriter&lt;Output&gt; writer(output);</code></pre></td></tr></table></div>
<p>See example <code>examples/cpp/core/output_stream_allocator</code>.</p>
<h1 id="custom-streams">Custom streams</h1>
<p>Applications can define custom buffers used for writing/reading data during <a href="#serialization">de/serialization</a>.</p>
<p>An input stream class implements the following input stream concept <a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">class</span> InputStream
{
<span class="kw">public</span>:
    <span class="co">// Read overload(s) for arithmetic types</span>
    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;
    <span class="dt">void</span> Read(T&amp; value);

    <span class="co">// Read into a memory buffer</span>
    <span class="dt">void</span> Read(<span class="dt">void</span> *buffer, <span class="dt">uint32_t</span> size);

    <span class="co">// Read into a memory blob</span>
    <span class="dt">void</span> Read(bond::blob&amp; blob, <span class="dt">uint32_t</span> size);
};</code></pre></td></tr></table></div>
<p>An output stream class implements the following output stream concept:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">class</span> OutputStream
{
<span class="kw">public</span>:
    <span class="co">// Write overload(s) for arithmetic types</span>
    <span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
    <span class="dt">void</span> Write(<span class="dt">const</span> T&amp; value);

    <span class="co">// Write a memory buffer</span>
    <span class="dt">void</span> Write(<span class="dt">const</span> <span class="dt">void</span>* value, <span class="dt">uint32_t</span> size);

    <span class="co">// Write a memory blob</span>
    <span class="dt">void</span> Write(<span class="dt">const</span> bond::blob&amp; blob);
};</code></pre></td></tr></table></div>
<h1 id="scoped-enumerations">Scoped enumerations</h1>
<p>Bond provides a standard-compliant solution for scoped enumerations in C++ that overcomes the limitations of normal C++ enumeration types. Usually enumerations are part of a schema used with library Bond APIs. However applications can use the following technique to defined standalone enum types.</p>
<p>Define your enumerations in a .bond file. You can use the same identifiers for constants in different enumerations in the same namespace scope.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="kw">namespace</span> example

<span class="kw">enum</span> Fruit
{
    Orange = <span class="dv">1</span>,
    Apple = <span class="dv">2</span>
}

<span class="kw">enum</span> Color
{
    Green = <span class="dv">1</span>,
    Orange = <span class="dv">7</span>
}</code></pre></td></tr></table></div>
<p>Use the <code>--enum-header</code> gbc compiler option to generate a standalone <em>filename</em><code>_enum.h</code> header file that you can include for scoped enumerations.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp"><span class="ot">#include &quot;enumerations_enum.h&quot;</span>

<span class="dt">int</span> main()
{
    example::Fruit fruit;
    example::Color color;

    fruit = example::Fruit::Orange;
    fruit = example::Apple;

    color = example::Green;
    color = example::Color::Orange;

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></td></tr></table></div>
<p>This solution uses the Bond compiler to generate the code that you use but your code does not take a dependency on the Bond library.</p>
<p>See example: <code>examples/cpp/core/enumerations</code>.</p>
<h1 id="exceptions">Exceptions</h1>
<p>Bond uses C++ exceptions to communicate errors. All exceptions derive from <code>std::exception</code> and implement the <code>what()</code> method which returns a human readable description of the error. The following exceptions can be thrown during calls to Bond APIs:</p>
<h2 id="bondexception"><code>bond::Exception</code></h2>
<p>Bond-specific errors are reported using exceptions derived from <code>bond::Exception</code> which itself derives from <code>std::exception</code>. The following exception types are defined:</p>
<ul>
<li><p><code>bond::CoreException</code></p>
<p>Used to indicate errors such as a missing required field during deserialization or an invalid protocol during unmarshaling.</p></li>
<li><p><code>bond::StreamException</code></p>
<p>Used to indicate errors related to reading from or writing to a data stream, for example attempting to read past the end of data stream.</p></li>
</ul>
<h2 id="stdbad_alloc"><code>std::bad_alloc</code></h2>
<p>Failure to allocate memory. For example, this exception can be thrown if the payload being deserialized contains a container with more elements than can be fit into available memory.</p>
<h2 id="stdlength_error"><code>std::length_error</code></h2>
<p>The standard library throws this exception to report errors that are consequence of attempt to exceed implementation-defined lengths for objects such as <code>std::string</code> or <code>std::vector</code>.</p>
<h2 id="stdrange_error"><code>std::range_error</code></h2>
<p>The standard library <code>std::wstring_convert::from_bytes</code> and <code>std::wstring_convert::to_bytes</code> which are used by Bond JSON de/serializer throw this exception to indicate an invalid string encoding.</p>
<h1 id="optimizing-build-time">Optimizing build time</h1>
<p>Extensive use of C++ templates in Bond may sometimes lead to long compilation times. In order to optimize build speed for projects using Bond, it is important to understand how the Bond implementation in particular, and C++ templates in general, affect compilation and linking time.</p>
<p>At the high level, the cost of compiling template heavy C++ code comes from template instantiation. In Bond the most expensive templates to instantiate are related to deserialization. Deserialization APIs are usually instantiated for all enabled <a href="#protocols">protocols</a>. This leads to the first obvious way to optimize build speed: enable only the protocols that are needed.</p>
<p>The following built-in protocols are enabled by default:</p>
<ul>
<li>Compact Binary</li>
<li>Fast Binary</li>
<li>Simple Binary</li>
</ul>
<p>Two sets of macros control which built-in protocol are enabled.</p>
<ul>
<li><p>Enable a specific protocol and disable all others</p>
<ul>
<li><code>BOND_COMPACT_BINARY_PROTOCOL</code></li>
<li><code>BOND_SIMPLE_BINARY_PROTOCOL</code></li>
<li><code>BOND_FAST_BINARY_PROTOCOL</code></li>
<li><code>BOND_SIMPLE_JSON_PROTOCOL</code></li>
</ul></li>
</ul>
<p>It is critical that these macros are always defined the same way for all compilation units that will be linked into a particular executable. Failure to do so may lead to violation of the C++ One Definition rule <a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>. To avoid this problem the recommended way to set these macros is via the C++ compiler command line flags in the makefile, e.g.:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">/DBOND_COMPACT_BINARY_PROTOCOL /DBOND_SIMPLE_BINARY_PROTOCOL</code></pre></td></tr></table></div>
<p>C++ templates are instantiated separately in every compilation unit. This means that building an application which has calls to Bond APIs deserializing a particular schema in multiple .cpp files will result in repeated instantiation of the same templates, unnecessarily increasing build time. In order to mitigate this problem, the Bond compiler generates two additional files for each schema file: <em>filename</em><code>_apply.h</code> and <em>filename</em><code>_apply.cpp</code>. Using these files is optional but for most non-trivial applications it will result in significant improvement of build time. The <code>_apply.cpp</code> can be built as part of the application project itself, but often it is better to compile it into a separate static library. This way the static library needs to be rebuilt only when the schemas change, and otherwise applications can be quickly built and linked with the schema library. The <em>filename</em><code>_apply.h</code> can be thought of as a header file for the schema library; it must be included in every compilation unit where Bond APIs are called for any schema defined in <em>filename</em><code>.bond</code>.</p>
<p>The Bond compiler command line switch <code>--apply</code> can be use to control which protocols are included in the generated <code>_apply</code> files. This can be used to reduce compilation time for <code>_apply.cpp</code>.</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">gbc c++ --apply=fast example.bond</code></pre></td></tr></table></div>
<p>Compiling generated <em>filename</em><code>_apply.cpp</code> results in instantiation of all the templates used by the most common APIs such a Serialize and Deserialize for all the schemas defined in <em>filename</em><code>.bond</code>. For applications with very large schemas it is often beneficial to spread the schema definitions across multiple <code>.bond</code> files. This allows building in parallel multiple, smaller <code>_apply.cpp</code> files rather that one large file.</p>
<p>C++ templates for Bond internal schemas, such as those used to serialize runtime schema, are pre-instantiated and included in Bond static libraries. It is recommended that applications include the header file <code>bond/core/bond_apply.h</code> and link to the <code>bond_apply</code> static library in order to reuse the pre-instantiated code. The one exception are applications using custom protocols - by definition templates pre-instantiated at the time Bond library was built can’t support custom protocols.</p>
<p>When using the Microsoft Visual Studio toolchain there are two important things to be aware related to build time. First, always use 64-bit tools. In particular the 32-bit version of link.exe is not capable of linking large template-based code. It will either fail, or if you are unlucky, it will run several orders of magnitude times longer than the 64-bit version. You can force 64-bit tools using environment variables:</p>
<p>For Visual Studio 2012:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">set _IsNativeEnvironment=<span class="kw">true</span></code></pre></td></tr></table></div>
<p>For Visual Studio 2013:</p>
<div class="sourceCode"><table class="sourceCode cpp numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode cpp">set PreferredToolArchitecture=x64</code></pre></td></tr></table></div>
<p>Link-time code generation can also lead to egregiously long link times. It is strongly recommended to disable it for projects using Bond. Link-time code generation does not improve runtime performance for Bond APIs and in many cases it actually degrades it. If application code <em>must</em> be built with LTCG enabled, we recommend using a separate static schema library as described above, and disabling LTCG when building the library.</p>
<p>See example: <code>examples/cpp/core/static_library</code>.</p>
<h1 id="references">References</h1>
<h2 id="c-api-referenceapi_reference"><a href="../reference/cpp/index.html">C++ API reference</a></h2>
<h2 id="bond-compiler-referencecompiler"><a href="compiler.html">Bond compiler reference</a></h2>
<h2 id="c-users-manualbond_cs"><a href="bond_cs.html">C# User’s Manual</a></h2>
<h2 id="python-users-manualbond_py"><a href="bond_py.html">Python User’s Manual</a></h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In Bond there is no concept of default for structs and thus default of <code>nothing</code> can’t be set for fields of struct types or <code>bonded&lt;T&gt;</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Some protocols might not support omitting optional fields (e.g. Simple Protocol) or omitting fields may be disabled by specializing <code>bond::may_omit_fields</code> trait. In such cases an attempt to serialize an object with field(s) set to <code>nothing</code> will result in a runtime exception.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>An object of a derived type will be sliced to the type <code>T</code>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Cost of deserializing <code>bonded&lt;T&gt;</code> is protocol dependent. Most protocols need to parse the payload in order to find where the corresponding struct ends. Compact Binary version 2 stores length prefix for structs and thus can deserialize a <code>bonded&lt;T&gt;</code> field in constant time.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>As an optimization, if the data is already encoded in the target protocol Bond will simply copy the payload.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Reviewing <code>apply.h</code> will reveal that in fact there are a few more overloads of <code>Apply</code>, and their signatures are more complex. However these can be considered implementation details, only defined to enable the compiler to select of the proper implementation in various scenarios. Conceptually, the <code>Apply</code> API can be called to apply a transform to one of three <em>things</em>: <code>bonded&lt;T&gt;</code>, <code>value&lt;T&gt;</code> or an instance of a Bond class.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>The default implementation assumes broadly used STL conventions and may work for many container implementations from libraries such as Boost. For such containers is not necessary to specialize the enumerators.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Note that input/output streams are not <em>interface classes</em> which can be derived from. They are conceptual interfaces, a set of method signatures that need to be implemented. Furthermore, the Read and Write templates don’t have to be implemented as a single method template (or, for that matter, as a template at all). They merely mean that a Read/Write method overload must be defined for every arithmetic type in Bond meta-schema.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Since breaking the C++ One Definition rule may lead to very unpredictable runtime behaviour, the Bond implementation has a built-in assertion mechanism to detect it.<a href="#fnref9">↩</a></p></li>
</ol>
</div>
</div>    
</div>
</body>
</html>
