<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>A Thorough Guide to Bond for C#</title>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  body {
      line-height: 1.5;
      font-family: Helvetica, Arial, sans-serif;
      color: #333333;
      font-size: 1em;
  }
  code {
      font-size: 1em;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace, serif;
  }
  td.lineNumbers { width: 40px; }
  div#all {
    max-width: 1120px;
    background-color: #ffffff;
    margin: 0 auto;
    padding: 25px;
    overflow: auto;
  }
  code > span.kw { color: #204a87; font-weight: normal; } /* Keyword */
  code > span.co { color: #4E9A06; font-style: normal; }
  code > span.st { color: #8A0303; font-style: normal; }
  code > span.cf { color: #204a87; font-weight: normal; } /* ControlFlow */
  code > span.op { color: #000000; font-weight: normal; } /* Operator */
  code > span.pp { color: #8f5902; font-style: normal; } /* Preprocessor */
  code > span.ex { } /* Extension */
  code > span.at { color: #c4a000; } /* Attribute */
  code > span.do { color: #8f5902; font-weight: normal; font-style: normal; } /* Documentation */
  code > span.an { color: #8f5902; font-weight: normal; font-style: normal; } /* Annotation */
  code > span.cv { color: #8f5902; font-weight: normal; font-style: normal; } /* CommentVar */
  code > span.in { color: #8f5902; font-weight: normal; font-style: normal; } /* Information */

  h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    border-bottom: 1px solid black;
  }

  div.sourceCode {
    overflow-x: auto;
    max-height: 620px;
  }

  table.sourceCode {
    line-height: 120%;
  }

  #toc {
    width: 300px;
    position:fixed;
    overflow: auto;
    height: 95%;
  }

  #main {
    margin-left: 320px;
    margin-rigth: auto;
    max-width: 800px;
  }
  a {
    text-decoration: none;
  }
  #toc a:visited {
    color: #99c;
  }
  #main a:visited {
    color: #36c;
  }
  a:link {
    color: #36c;
  }
  @media screen and (max-width: 979px){
  #main {
    margin-left: auto;
    margin-right: auto;
  }
  #toc {
    left: -300px;
  }
  }
  </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58775439-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav id="TOC"/>
<div id="all">
<div id="toc">
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAB3RJTUUH4AkNAgoHQuWiyQAACYlJREFUeNrtm3twVNUdxz/33t3N7pL3OyRkISQQKiBoCGApoK2KVKlUHhVQwFZQWywWxnGm7egwtkWdoVREitFQXhYoRRSICsFYaSU2nQRMAoEEyIu8YEM2m93N3rt7T/9IGo20dKG0JGW/M/vH3Xv3nHs+5/f7nd/53buSEEJwE0vmJlcQQBBAEEAQQBBAEEAQQBBAEEAQQBDAzSnD9WjE4XDwccFHFBWXcMF+CVVVURQFi9lMRHgYMVFRJCbEkZSURGxMLGaLhcSkJEJDQ284AOl6bIfnPfw9CpzhmBMGoxiNSJKMEAIhdHSfD+FT8Xs9aB1tCHc7ZmcTM7JHsG79673acblc5OcfInN4JsMzM/uuBfg0jUsOBzU1tVxqbeXjk3XEz3wmANwSsjGExkPbsKUOuuz0htdf57kXX8EvKdBuJ9mWyrjbbyM76zbmzplDWlrajQXg8XjIy8tj48YccFfwrRG1FJRHog+cHVgDQiA0L81H9pKw+NvU1taSmprac9rrdpE05SHiJs3A7+5AdbZyvP0SB7ft5/PjZbz66lri4mL/Ny7g8/nQNI2GhgZ2797Nzp07KS0tZXx2FsWfn+FkjorN5mDYghik+1dhjo4PqEPnuXJCinYRExXF8ePH6ezsJDU1lXHjxlF2rBh1yvexpmQgdL3rBhUDF3avZkJEGUeOuxmamcW77+0nPj7++ltAW1sb+fn5HD16lJMVFWjeTqwWM7IsM3bMKH70xA8YPnwYix7/MbaUKs6eGUCVI5xbEwehq96AOrx4soh1zz7LwoULAfD7/VRXV3PixAmWFRYSmTIMofu/mCFZZohUzh9/5oEQhTU7ypkzdx4fHT6ILMvXF8CuXbtYunQpyckDeWX1L0hMiKel5QJeVWXIYBvVNbU0NrVwyyAPCJV3PhEkTbgb4fcH7ALGjgssX76cRYsWkZycTHZ2NhMnTuzy77ghIF1mpJh0N7ouI6t+MlMVVmz4EwaDgbCwMEaPHk12djZZWVlkZWWRlpaGoijXBmDJkiXMmjWLvLw83t1/gJaWJgZYzdw+diwREeEMSx9K+clKRtmc4JP5S6lG9NQ7es3YlccvSIkKpbDoPA0NDZw+fYrKyiqqa2rYtnUr3uSsHtP/0q/wMADV58asgKZ6WfLEk2zc8Cr19fVUVlZy6tQpiouL2bNnD2VlZaxatYrZs2dfWxCMjo5mwYIFzJ8/H1VVqampYf369Ty66HEGD7YxJC2DxVkevG5o0aJRBkQh/CqSLHeDkK6wCEg0+kKIS0hEtoSB1G3CXhd+JFImPwZfCUnC7+ec5Q7ONRcwwuanzm7kD7t2IgmVcePGMX78eO68886e63fs2EF7e/t/Jw/Iz89nzdp1TE7+iGUP6Ez55RB8019EkmTObn6B2An3E5YxFmQFdB9eeyNqWwt6pxtjZByWgUORDSZkg6EblOgxcyF0/N5OEPpl/Xoddpz7Xmb9gjpe2K6w7q2DlJaWUl5eTlVVFXa7HbPZTGRkJK2trSxdurQnxlz3RMjlcjF/3lwO5R1AirOR/tRa/B4XJ1Y/Suay39B5sQFHxV9xVBRhSbARarsFU3Q89sIDDJr7LMaImMtmOYDbRNe8tB7dS2PBbhY+soA3czf1+LqqqqiqitfrRdM0oqKiCAkJ+e9mgg6Hg3vuuZv2OxZjSbTR+rd82ko/wRAWTeiQkUSMGI9iCUP3a6DrNHywicSpc5BMli/N/FViMJiQZYm6g9sZKdv58P0DmEymG5cKlxQXM/Xe6bitcSTcPpXIjLGYYgYCAuHzIYTeNdvdKbEkK9c8+N53LdN45B0mmC/x3r79N34v8H7eAfbu2UPRZ4U4OlwISyT6gCh0SwS6JQzMYSihkRgsoUjGECRFwWAwoSMjyXIXGElCMRpQQqwB9amYrVSs/SEf7NjE5ClTbyyAXumy243D4cDpdOLq6MDldtHhdGK327l48SKtbQ7cnV5yc9/gvolm/H5weE2oPoljZyF5yVqETw3IClR7A+Nbj5K7ees1J0UGrrMsVisWq5XEpKR/ec2nn37KmSOr2bq8eyWQAKFw7wo/LeiBOYnQMUbFU/DJOTRNCzjo3fCCiBCCmbPm89JSC/gATQJVAj8MMIHf1Q6SFJj5SjJ2JYLCwsL+UxH69dr1LJjsIN3muSweWq0GvK1NSAECAIgaOpI338rtHwBqa2vZvWUVLy1ygrd7kGaotYfwyGpBQVkYXnvjFxliAAq3ZbJ3796+D8DlcjF2zGjWPu7CIHftHTp9ISx/LYwxT4Xw8E/2serFX+Fqqg7YBQBCohPpUP3U19X1jSD4z9Ta2so3757OynmxONrP8PPN8Hl9NJ3WSXxnxgNc3PEYsixTcPgwrrpKJFlBoAUWU3Sd8KGjOFZSQsqgQX0TQE5ODseKP0N1Z1B/1xPMXPwQP500CaPR2Gvr+rWRI/GcP4t0FW0LoRNqG8GJ8lLunzHjxucB/6mMFivDn/ltwAmRJCu46k5yl+80G3N/1/+fC3x94kTcLfVXZQGW+EE0NTVyLXPZ5wBMv28arqbarnKZpyOgKpNiCcPp7kTTtP4P4LsPPoizrhKQaPxwc0DVJiHAo8v4fL7+DyA5JYUkkwYIJEnC1+G4fFn86rEQeIWMP9DaZF8GYDKZGJUYjvC6ic66h5odL6EYzV0VJEkGBN6W+i8gSBKSwYQqGdD/HwAoisK0adNo+fNeQtPHEnnrFKpynkO1N+CpLuP0a8vpbKlBkhX8nW7c58/Q8mEuSnvLVSVQfXYZhK4nUFExsaQ//RqGsGhc1eW4qstRTBYiRn8DraOdM/nvMSb8LEnyeUTkVDZt2UpsbOxV7SP6LACALVu28OTLOaTPWtZdZNXRnHaa9m0gjZNsXGFmjK2DbUdieHKNE7ens28URK6nnn56GW+8X4g1OZ22yuPcO/giK2Z6cDi97CsUHCpRGJg2nt9ve4v09PRr3p/3aRUXF4ucnBzx9ttvC0BYrVaxePFikZGRIboLjMJisYiVK1eK06dPCyGE0HVd6Lre08Y/jhsbG3t9L4QQUn96XV4I0ePjeXl5rFmzhsOHD/euSFkspKenEx8fj9lsRlVVmpubqaioQFVVtm/fzrx58/qPBVxJmqaJpqYm8fzzz4vExMQei7jSp6ioqP9awL9TQ0MDJSUlVFVV0dzcjMfjwWQykZCQQGZmJpMnT77stRwp+I+Rm1xBAEEAQQBBAEEAQQBBAEEAQQBBAEEAN6f+DmFDv1c4Q3HPAAAAAElFTkSuQmCC" alt="The Bond logo: a stylized glue gun" /></p>
<ul>
<li><a href="#bond-project-has-ended">Bond project has ended</a></li>
<li><a href="#about">About</a></li>
<li><a href="#basic-example">Basic example</a></li>
<li><a href="#code-generation">Code generation</a></li>
<li><a href="#serializer">Serializer</a></li>
<li><a href="#deserializer">Deserializer</a></li>
<li><a href="#marshaling">Marshaling</a></li>
<li><a href="#schema-evolution">Schema evolution</a></li>
<li><a href="#default-values">Default values</a></li>
<li><a href="#default-value-of-nothing">Default value of <code>nothing</code></a></li>
<li><a href="#nullable-types">Nullable types</a></li>
<li><a href="#protocols">Protocols</a><ul>
<li><a href="#compact-binary">Compact Binary</a></li>
<li><a href="#fast-binary">Fast Binary</a></li>
<li><a href="#simple-binary">Simple Binary</a></li>
<li><a href="#simple-json">Simple JSON</a></li>
</ul></li>
<li><a href="#transcoder">Transcoder</a></li>
<li><a href="#input-and-output-streams">Input and output streams</a></li>
<li><a href="#cloner">Cloner</a></li>
<li><a href="#comparer">Comparer</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#runtime-schema">Runtime schema</a></li>
<li><a href="#understanding-bondedt">Understanding <code>bonded&lt;T&gt;</code></a><ul>
<li><a href="#lazy-deserialization">Lazy deserialization</a></li>
<li><a href="#pass-through">Pass-through</a></li>
<li><a href="#polymorphism">Polymorphism</a></li>
</ul></li>
<li><a href="#custom-type-mappings">Custom type mappings</a><ul>
<li><a href="#codegen-parameters">Codegen parameters</a></li>
<li><a href="#custom-containers">Custom containers</a></li>
<li><a href="#system.collection.immutable-support">System.Collection.Immutable support</a></li>
<li><a href="#converter">Converter</a></li>
</ul></li>
<li><a href="#xml">Xml</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#attributes">Attributes</a><ul>
<li><a href="#schema-decoration">Schema decoration</a><ul>
<li><a href="#schemaattribute">SchemaAttribute</a></li>
<li><a href="#namespaceattribute">NamespaceAttribute</a></li>
<li><a href="#idattribute">IdAttribute</a></li>
<li><a href="#requiredattribute">RequiredAttribute</a></li>
<li><a href="#typeattribute">TypeAttribute</a></li>
<li><a href="#defaultattribute">DefaultAttribute</a></li>
<li><a href="#attributeattribute">AttributeAttribute</a></li>
</ul></li>
<li><a href="#protocol-decoration">Protocol decoration</a><ul>
<li><a href="#readerattribute">ReaderAttribute</a></li>
<li><a href="#parserattribute">ParserAttribute</a></li>
<li><a href="#serializerattribute">SerializerAttribute</a></li>
</ul></li>
</ul></li>
<li><a href="#nuget-packages">NuGet packages</a><ul>
<li><a href="#platform-limitations">Platform limitations</a></li>
<li><a href="#frameworks-targeted">Frameworks targeted</a></li>
</ul></li>
<li><a href="#references">References</a><ul>
<li><a href="#bond-compiler-referencecompiler"><a href="compiler.html">Bond compiler reference</a></a></li>
<li><a href="#c-users-manualbond_cpp"><a href="bond_cpp.html">C++ User’s Manual</a></a></li>
<li><a href="#python-users-manualbond_py"><a href="bond_py.html">Python User’s Manual</a></a></li>
</ul></li>
</ul>
</div>
<div id="main">
<div id="header">
<h1 class="title">A Thorough Guide to Bond for C#</h1>
</div>
<h1 id="bond-project-has-ended">Bond project has ended</h1>
<p>As of March 2025, the Bond open-source project has ended. There will be no further activity in this project: no new features, no bug fixes, and, importantly, no security fixes.</p>
<p>The documentation as it existed at the time of the end of the project follows.</p>
<h1 id="about">About</h1>
<p>Bond is an extensible framework for working with schematized data. It is suitable for scenarios ranging from service communications to Big Data storage and processing.</p>
<p>Bond defines a rich type system and <a href="#schema-evolution">schema evolution rules</a> which allow forward and backward compatibility. The core Bond features include high performance serialization/deserialization and a very powerful, generic data transform mechanism. The framework is highly extensible via pluggable serialization protocols, data streams, user defined type aliases and more.</p>
<p>By design Bond is language and platform independent and is currently supported for C++, C#, Java, and Python on Linux, macOS, and Windows.</p>
<p>Bond is published on GitHub at <a href="https://github.com/microsoft/bond/" class="uri">https://github.com/microsoft/bond/</a>.</p>
<h1 id="basic-example">Basic example</h1>
<p>In Bond data schemas are defined using idl-like <a href="compiler.html#idl-syntax">syntax</a>:</p>
<pre><code>namespace Examples

struct Record
{
    0: string Name;
    1: vector&lt;double&gt; Constants;
}</code></pre>
<p>In order to use the schema in a C# program, it needs to be compiled using the Bond compiler. This step is sometimes also referred to as code generation (or codegen) because the compilation generates C# code corresponding to the schema definition.</p>
<pre><code>gbc c# example.bond</code></pre>
<p>Using the generated C# code, we can write a simple program that will serialize and deserialize an instance of the Record schema using <a href="bond_cpp.html#compact-binary">Compact Binary</a> protocol:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">namespace</span> Examples
{
    <span class="kw">using</span> Bond;
    <span class="kw">using</span> Bond.<span class="fu">Protocols</span>;
    <span class="kw">using</span> Bond.<span class="fu">IO</span>.<span class="fu">Safe</span>;

    <span class="kw">class</span> Program
    {
        <span class="kw">static</span> <span class="dt">void</span> <span class="fu">Main</span>()
        {
            <span class="dt">var</span> src = <span class="kw">new</span> Record
            {
                Name = <span class="st">&quot;FooBar&quot;</span>,
                Constants = { <span class="fl">3.14</span>, <span class="fl">6.28</span> }
            };

            <span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>();
            <span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

            <span class="co">// The first calls to Serialize.To and Deserialize&lt;T&gt;.From can take</span>
            <span class="co">// a relatively long time because they generate the de/serializer</span>
            <span class="co">// for a given type and protocol.</span>
            Serialize.<span class="fu">To</span>(writer, src);

            <span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(output.<span class="fu">Data</span>);
            <span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputBuffer&gt;(input);

            <span class="dt">var</span> dst = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);
        }
    }
}</code></pre></div>
<h1 id="code-generation">Code generation</h1>
<p>In order to use a Bond schema in a C# program, it needs to be compiled using the Bond compiler <a href="compiler.html"><code>gbc</code></a>. The compiler generates C# classes that represent the schema. By default schema fields are represented by public auto-properties initialized in the default constructor.</p>
<p>The mapping between Bond and C# type systems is mostly obvious, but it is worth noting that, unlike C# reference types, Bond types are not nullable. This means that <code>string</code> in Bond IDL will be mapped to C# <code>string</code>, which is a reference type, but the value <code>null</code> will not be valid. In order to allow <code>null</code> values, a type must be declared as <a href="bond_cpp.html#nullable-types"><code>nullable</code></a>, e.g.:</p>
<pre><code>struct Foo
{
    0: list&lt;nullable&lt;string&gt;&gt; listOfNullableStrings;
}</code></pre>
<p>The value <code>null</code> is also legal for fields declared in Bond IDL to have a <a href="bond_cpp.html#default-value-of-nothing">default of <code>nothing</code></a>, e.g.:</p>
<pre><code>struct Bar
{
    0: string str = nothing;
}</code></pre>
<p>Code generation can be customized by passing one or more of the following command line options to <code>gbc</code>:</p>
<p><code>--fields</code></p>
<p>Schema fields are represented by public fields with initializers and no constructor is generated.</p>
<p><code>--readonly-properties</code></p>
<p>Schema fields are represented by properties with public getter and private setter and initialized to the default values in the default constructor. Classes with read-only properties are fully supported by all Bond APIs.</p>
<p><code>--preview-constructor-parameters</code></p>
<p>A constructor is generated with a parameter to initialize each of the schema fields. This option is typically used in conjunction with <code>--readonly-properties</code>. This functionailty is in preview and may change.</p>
<p><code>--collection-interfaces</code></p>
<p>Collection types <code>vector&lt;T&gt;</code>, <code>map&lt;K, V&gt;</code>, <code>list&lt;T&gt;</code> and <code>set&lt;T&gt;</code> are represented by respective generic collection interfaces: <code>IList&lt;T&gt;</code>, <code>IDictionary&lt;K, V&gt;</code>, <code>ICollection&lt;T&gt;</code> and <code>ISet&lt;T&gt;</code>.</p>
<h1 id="serializer">Serializer</h1>
<p>Bond serialization API is provided by the <code>Serializer</code> class. It is a generic class parameterized with type of protocol writer used for serialization:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Serializer&lt;CompactBinaryWriter&lt;OutputStream&gt;&gt;</code></pre></div>
<p>The constructor of the <code>Serializer</code> class takes the type of a class or struct representing Bond schema:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputStream&gt;&gt;(<span class="kw">typeof</span>(Record))</code></pre></div>
<p>The constructor is non-trivial so application usually should create an instance of <code>Serializer</code> outside of the inner loop and reuse it.</p>
<p>The <code>Serializer</code> class exposes one public method <code>Serialize</code> which takes two arguments, an object to be serialized and an instance of the protocol writer to be used for serialization.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">serializer.<span class="fu">Serialize</span>(obj, writer);</code></pre></div>
<p>The object’s type must be the same as the type passed to the <code>Serializer</code> constructor, otherwise the behaviour is undefined.</p>
<p>Bond provides a helper static API for applications that use schema types known at compile-time and don’t need to manage lifetime of the <code>Serializer</code>:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Serialize.<span class="fu">To</span>(writer, obj);</code></pre></div>
<p>When the API is called for the first time, a static instance of appropriate <code>Serializer</code> is created. Because of this the first call to the API for given type and protocol may take relatively long time. Subsequent calls for the same writer/object types reuse the static instance.</p>
<h1 id="deserializer">Deserializer</h1>
<p>Bond serialization API is provided by the <code>Deserializer</code> class. It is a generic class parameterized with type of the protocol reader to be used for deserialization:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Deserializer&lt;CompactBinaryReader&lt;InputStream&gt;&gt;</code></pre></div>
<p>The constructor of the <code>Deserializer</code> class takes the type of a class or struct representing Bond schema:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">new</span> Deserializer&lt;CompactBinaryReader&lt;InputStream&gt;&gt;(<span class="kw">typeof</span>(Record))</code></pre></div>
<p>The constructor is non-trivial so application usually should create an instance of <code>Deserializer</code> outside of the inner loop and reuse it.</p>
<p>The <code>Deserializer</code> class exposes one generic public method <code>Deserialize</code> which takes as an argument an instance of the protocol reader and returns a deserialized object:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> record = deserializer.<span class="fu">Deserialize</span>&lt;Record&gt;(reader);</code></pre></div>
<p>The object created by <code>Deserialize</code> is always of the type specified during <code>Deserializer</code> construction. The type parameter of the method is only used to cast the result.</p>
<p>Deserializing from payload encoded in an untagged protocol like Simple usually requires specifying schema of the payload. To address this scenario the <code>Deserializer</code> class has an additional constructor taking a <a href="#runtime-schema"><code>RuntimeSchema</code></a> as an argument:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">RuntimeSchema schema;
<span class="co">// ...</span>
<span class="dt">var</span> d = <span class="kw">new</span> Deserializer&lt;SimpleReader&lt;InputStream&gt;&gt;(<span class="kw">typeof</span>(Record), schema);
<span class="dt">var</span> obj = d.<span class="fu">Deserialize</span>&lt;Record&gt;(reader);</code></pre></div>
<p>An instance of <code>Deserializer</code> created this way is tied to the triplet of protocol, object type and payload schema. In order to deserialize from payload in another schema a new instance of <code>Deserializer</code> needs to be created.</p>
<p>Bond provides a helper static API for applications that use schema types known at compile-time, don’t need to specify payload schema and don’t need to manage lifetime of the <code>Deserializer</code>:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> obj = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></div>
<p>When an application calls this API for the first time, a static instance of appropriate <code>Deserializer</code> is created. Because of this the first call to the API for given type and protocol may take relatively long time. Subsequent calls for the same reader/object types reuse the static instance.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/untagged_protocols</code></li>
</ul>
<h1 id="marshaling">Marshaling</h1>
<p>Since Bond supports multiple serialization <a href="bond_cpp.html#protocols">protocols</a>, application endpoints either have to agree on a particular protocol, or include protocol metadata in the payload. Marshaling APIs provide the standard way to do the latter, by automatically adding a payload header with the protocol identifier and version.</p>
<p><code>Marshal</code> and <code>Unmarshal</code> APIs are very similar to <code>Serialize</code> and <code>Deserialize</code>, except that when calling <code>Unmarshal</code> the application simply provides an input stream with payload data, rather than an instance of a particular protocol reader:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> src = <span class="kw">new</span> Example
{
    Name = <span class="st">&quot;foo&quot;</span>,
    Constants = { <span class="fl">3.14</span>, <span class="fl">6.28</span> }
};

<span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

Marshal.<span class="fu">To</span>(writer, src);

<span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(output.<span class="fu">Data</span>);

<span class="dt">var</span> dst = Unmarshal&lt;Example&gt;.<span class="fu">From</span>(input);</code></pre></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/marshaling</code></li>
</ul>
<h1 id="schema-evolution">Schema evolution</h1>
<p>Bond does not use explicit versioning to deal with changes to schemas (and the resulting types) over time. Instead, Bond supports certain schema evolution operations which allow the producer and consumer of Bond types to evolve without lockstep coordination.</p>
<p>The following changes to a schema will never break compatibility across the wire:</p>
<ul>
<li>Adding or removing an <code>optional</code> or <code>required_optional</code> field</li>
<li>Changing a field’s type between <code>int32</code> and <code>enum</code></li>
<li>Changing a field’s type between <code>vector&lt;T&gt;</code> and <code>list&lt;T&gt;</code></li>
<li>Changing a field’s type between <code>blob</code> and <code>vector&lt;int8&gt;</code> or <code>blob</code> and <code>list&lt;int8&gt;</code></li>
<li>Changing a field’s type between <code>T</code> and <code>bonded&lt;T&gt;</code></li>
<li>Adding new enumeration constants that don’t alter existing constants (beware of implicit reordering)</li>
</ul>
<p>The following changes to a type are generally safe but require some consideration about how the change is rolled out:</p>
<ul>
<li>Changing a field between <code>optional</code> and <code>required_optional</code> or between <code>required_optional</code> and <code>required</code>. The <code>required_optional</code> modifier facilitates a two-step process for changing between <code>optional</code> and <code>required</code>, but the first step must be completed on both the producer and the consumer sides before the second step can be started on either side.</li>
<li>Promoting a field with a numeric type from a smaller size to a larger size (e.g.: <code>float</code> to <code>double</code>, <code>uint8</code> to <code>uint16</code>, <code>uint8</code> to <code>uint32</code>, <code>int8</code> to <code>int16</code>, etc.). The consumer must get the change before the producer. Note that changing from unsigned to signed or vice versa is <em>not</em> compatible (e.g.: <code>uint8</code> to <code>int16</code>).</li>
<li>Promoting from <code>int8</code> or <code>int16</code> to <code>enum</code>. The consumer must get the change before the producer.</li>
</ul>
<p>These following changes will break wire compatibility and are not recommended:</p>
<ul>
<li>Adding or removing <code>required</code> fields</li>
<li>Incompatible change of field types (any type change <em>not</em> covered above); e.g.: <code>int32</code> to <code>string</code>, <code>string</code> to <code>wstring</code>, <code>float</code> to <code>nullable&lt;float&gt;</code></li>
<li>Changing of field ordinals/ids</li>
<li>Changing of inheritance hierarchy (add/remove/substituting base struct)</li>
<li>Changing between <code>required</code> and <code>optional</code> directly</li>
<li>Changing the default value of a field</li>
<li>Changing existing enumeration constants in any way (including implicit renumbering)</li>
</ul>
<p>Some best practices and other considerations to keep in mind:</p>
<ul>
<li>When removing a field, comment it out rather than removing it altogether so that the neither the field ordinal nor name are reused in future edits of the schema</li>
<li>When working with untagged protocols like <a href="#simple-binary">SimpleBinaryProtocol</a>, great care must be taken to ensure the same <a href="#runtime-schema">schema</a> is used when deserializing the payload as was used to serialize it.</li>
<li>Caution should be used when changing or reusing field names as this could break text-based protocols like <a href="#simple-json">SimpleJsonProtocol</a></li>
<li><code>required</code> should be used sparingly and only with careful consideration</li>
</ul>
<h1 id="default-values">Default values</h1>
<p>Fields of a Bond defined struct always have a default value, either explicitly specified in the .bond file, or the implicit default.</p>
<p>The implicit default is</p>
<ul>
<li><code>false</code> for <code>bool</code> fields</li>
<li>0 for arithmetic types</li>
<li>empty for string/containers</li>
<li><code>null</code> for <a href="#nullable-types">nullable type</a></li>
<li>for struct and <code>bonded</code> fields, an instance of a struct in which all of the fields are initialized to their default values, recursively</li>
</ul>
<p>There is no implicit default for enum fields: they must have an explicit default value in the .bond file.</p>
<p>Explicit default values (other than <a href="#default-value-of-nothing"><code>nothing</code></a>) may not be specified for <code>nullable</code> or container fields. Struct and <code>bonded</code> fields may not have an explicit default value. They always use their implicit default values.</p>
<p>The default values of fields matter because this is what an application will see after deserialization for any optional field that wasn’t present in the payload (e.g. when the payload was created from an older version of the schema).</p>
<p>Additionally, some protocols can omit <a href="bond_cpp.html#required-fields"><code>optional</code> non-struct fields</a> set to their default values, reducing payload size.</p>
<h1 id="default-value-of-nothing">Default value of <code>nothing</code></h1>
<p>Sometimes it is necessary to distinguish between any of the possible values of a field and absence of a value. To support such scenarios Bond allows non-struct fields’ default values to be explicitly set to <code>nothing</code> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<pre><code>struct AboutNothing
{
    0: uint16 n = nothing;
    1: string name = nothing;
    2: list&lt;float&gt; floats = nothing;
}</code></pre>
<p>Setting a field’s default to <code>nothing</code> doesn’t affect the schema type of the field, however it may affect what type the field is mapped to in the generated code. The reason why is pretty obvious: some types such as <code>ushort</code> just can’t represent absence of a value. In C# reference types already have a way to represent absence of value: <code>null</code>. For these types specifying a default of <code>nothing</code> doesn’t change the field type in the generated code. For C# value types such as <code>UInt16</code>, the generated code will use <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/">C# Nullable types</a> (e.g. <code>UInt16?</code>).</p>
<p>The fact that setting the default value of a field to <code>nothing</code> doesn’t affect the field’s schema type has an important consequence: the default value of the field doesn’t have a serialized representation. What this means in practice depends on whether the field is <code>optional</code> or <code>required</code>. Optional fields set to <code>nothing</code> are usually omitted during serialization <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, just like for any other default values. <a href="bond_cpp.html#required-fields">Required fields</a>, by definition, can never be omitted. Since <code>nothing</code> has no serialized representation, an attempt to serialize an object with required fields set to <code>nothing</code> will result in a runtime exception. If a null value needs to be represented in the serialized form, then a default of <code>nothing</code> is the wrong choice and a <a href="#nullable-types">nullable type</a> should be used instead.</p>
<h1 id="nullable-types">Nullable types</h1>
<p>For any type in the Bond meta-schema, <code>nullable&lt;T&gt;</code> defines a nullable type. A nullable type can store all the same values as its base type plus one additional value: <code>null</code>.</p>
<pre><code>struct Nullables
{
    0: nullable&lt;bool&gt;         b; // can be true, false, or null
    1: list&lt;nullable&lt;string&gt;&gt; l; // can be a (possibly empty) list or null
}</code></pre>
<p>The default value for a field of a nullable type is always implicitly set to <code>null</code>. Explicit default values for nullable fields are not supported.</p>
<p>In C# reference types already have a way to represent <code>null</code>: <code>null</code>. For these types <code>nullable&lt;T&gt;</code> and <code>T</code> will have the same type in the generated code. For C# value types such as <code>UInt16</code>, the generated code will use <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/">C# Nullable types</a> (e.g. <code>bool?</code>).</p>
<p>Caveat: <code>blob</code>, <code>nullable&lt;blob&gt;</code> and <code>blob = nothing</code> are all represented as an <code>ArraySegment&lt;byte&gt;</code> in the generated C# code. The C# default value for all three is <code>default(ArraySegment&lt;byte&gt;)</code> (in which the <code>Array</code> field is <code>null</code>). An empty <code>ArraySegment&lt;byte&gt;</code> (in which the <code>Array</code> field is not <code>null</code> but the <code>Count</code> is 0) is treated as a non-default value, so it will not be omitted for optional fields. This behavior will be changing in a future release, to align it with how other types are handled and how nullable/nothing fields are handled in other languages.</p>
<p>Since a nullable type must represent the additional value of <code>null</code>, its serialized representation necessarily incurs some overhead compared to the base type. Often it is more efficient to avoid using a nullable type and instead to designate one of the normal values to handle the special case that otherwise would be represented by <code>null</code>. For example <em>empty</em> is usually a good choice for string and container types and 0 for arithmetic types. Another option that may sometimes be appropriate is setting the default value of a non-struct field to <a href="#default-value-of-nothing"><code>nothing</code></a>. Struct fields can have neither an explicit default value nor be set to <code>nothing</code>, so <code>nullable</code> needs to be used if <code>null</code> semantics are needed for these fields.</p>
<p>The canonical scenario where a nullable type is the right choice is recursive structures. For example here’s how Bond <code>TypeDef</code> struct is defined:</p>
<pre><code>struct TypeDef
{
    // Type identifier
    0: BondDataType id = BT_STRUCT;

    // Index of struct definition in SchemaDef.structs when id == BT_STRUCT
    1: uint16 struct_def = 0;

    // Type definition for:
    //  list elements (id == BT_LIST),
    //  set elements (id == BT_SET),
    //  or mapped value (id == BT_MAP)
    2: nullable&lt;TypeDef&gt; element;

    // Type definition for map key when id == BT_MAP
    3: nullable&lt;TypeDef&gt; key;

    // True if the type is bonded&lt;T&gt;; used only when id == BT_STRUCT
    4: bool bonded_type;
}</code></pre>
<p>The <code>TypeDef</code> struct is used to represent the type of a field in a Bond schema. If the type is a container such as a list or map, the type definition becomes recursive. For example, a list type definition contains the type of the list element which of course itself can be a container of elements of some other type, and so on, until the recursion is terminated with a <code>null</code> value for the <code>element</code> and <code>key</code> fields.</p>
<h1 id="protocols">Protocols</h1>
<p>Bond protocols are pluggable, allowing application to choose the most appropriate encoding format. Bond supports three kinds of protocols:</p>
<ul>
<li><p>Tagged protocols</p>
<p>Tagged protocols interleave schema metadata within the payload. This makes the payload self-describing, allowing consumers to interpret it even without knowing the schema used by the producer.</p></li>
<li><p>Untagged protocols</p>
<p>Untagged protocols serialize only data and thus require that consumers know the payload schema via some out-of-band mechanism. Untagged protocols are often used in storage scenarios because they allow storing a <a href="#runtime-schema">schema</a> once (e.g. in a system table in a database) and thus eliminating metadata overhead from many records using the same schema.</p></li>
<li><p>DOM-based protocols</p>
<p>DOM-based protocol parse whole payload into an in-memory Data Object Model which then is queried during deserialization. Typically this kind of protocol is used to implement text based encoding such as JSON or XML.</p></li>
</ul>
<h2 id="compact-binary">Compact Binary</h2>
<p>A binary, tagged protocol using variable integer encoding and compact field header. A good choice, along with <a href="#fast-binary">Fast Binary</a>, for RPC scenarios.</p>
<p>Implemented in <code>CompactBinaryReader</code> and <code>CompactBinaryWriter</code> classes. Version 2 of Compact Binary adds length prefix for structs. This enables deserialization of <a href="#understanding-bondedt"><code>bonded&lt;T&gt;</code></a> and skipping of unknown fields in constant time. The trade-off is double pass encoding, resulting in up to 30% slower serialization performance.</p>
<p>See also <a href="../reference/cpp/compact__binary_8h_source.html">Compact Binary encoding reference</a>.</p>
<h2 id="fast-binary">Fast Binary</h2>
<p>A binary, tagged protocol similar to <a href="#compact-binary">Compact Binary</a> but optimized for deserialization speed rather than payload compactness.</p>
<p>Implemented in <code>FastBinaryReader</code> and<code>FastBinaryWriter</code> classes.</p>
<p>See also <a href="../reference/cpp/fast__binary_8h_source.html">Fast Binary encoding reference</a>.</p>
<h2 id="simple-binary">Simple Binary</h2>
<p>A binary, untagged protocol which is a good choice for storage scenarios as it offers potential for big saving on payload size. Because Simple is an untagged protocol, it requires that the payload schema is available during deserialization. In typical storage scenario application would store <a href="#runtime-schema">runtime schema</a> and use it during deserialization with <code>BondedVoid</code>. In some specific scenarios when it can be assumed that producer and consumer have exactly the same schema, SimpleProtocol can be used with compile-time schema, providing unparalleled deserialization performance. One example is marshaling objects between processes or between native and managed components.</p>
<p>Implemented in <code>SimpleBinaryReader</code> and <code>SimpleBinaryWriter</code> classes.</p>
<p>Version 2 of Simple Protocol uses variable integer encoding for string and container lengths, resulting in more compact payload without measurable performance impact.</p>
<p>See example: <code>examples/cs/core/untagged_protocols</code>.</p>
<h2 id="simple-json">Simple JSON</h2>
<p>The Simple JSON protocol is a simple JSON encoding implemented as a DOM protocol. The output is standard JSON and is a very good choice for interoperating with other systems or generating human readable payload.</p>
<p>Because the payload doesn’t include field ordinals, there are two caveats when used as a Bond serialization protocol:</p>
<ul>
<li>Transcoding from Simple JSON to binary Bond protocols is not supported (transcoding from a binary protocol to Simple JSON is supported if you have the schema).</li>
<li>Field matching is done by field name rather than ordinal. The implication is that renaming a field (which is considered a bad practice anyways) is a breaking schema change for Simple JSON.</li>
</ul>
<p>Simple JSON also flattens the inheritance hierarchy which may lead to name conflicts between fields of base and derived Bond structs. It is possible to resolve such conflicts without the need to actually rename the fields by annotating fields with <code>JsonName</code> attribute, e.g.:</p>
<pre><code>struct Base
{
    0: string foo;
}

struct Derived : Base
{
    [JsonName(&quot;DerivedFoo&quot;)]
    0: string foo;
}</code></pre>
<p>Note that Simple JSON is not designed to be able to read arbitrary JSON objects. Simple JSON has its own way of encoding Bond objects in JSON that differs from how other libraries would encode the same object. When interoperating with other JSON libraries, be aware of these differences:</p>
<ul>
<li>maps are encoded as arrays of key/value pairs not as sub-objects</li>
<li>the inheritance hierarchy is flattened</li>
<li>nulls are expressed as empty arrays</li>
<li>enums are encoded via their numeric value, not their symbolic names</li>
</ul>
<p>Implemented in <code>SimpleJsonReader</code> and <code>SimpleJsonWriter</code> classes.</p>
<p>See examples:</p>
<ul>
<li><code>examples/cs/core/simple_json</code></li>
</ul>
<h1 id="transcoder">Transcoder</h1>
<p>The <code>Transcoder</code> class provides API for converting payloads from one protocol into another. Transcoder operates directly on serialized data and doesn’t need to know the C# type representing payload schema.</p>
<p>The <code>Transcoder</code> is a generic class parameterized with types of source protocol reader and destination protocol writer, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Transcoder&lt;CompactBinaryReader&lt;InputStream&gt;, SimpleWriter&lt;OutputStream&gt;&gt;</code></pre></div>
<p>The constructor of the <code>Transcoder</code> class takes as an optional argument the <a href="#runtime-schema">runtime schema</a> of the payload. The argument is optional when transcoding between tagged protocols but must be specified when transcoding from an untagged protocol or to a text protocol.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">RuntimeSchema schema;
<span class="co">// ...</span>
<span class="dt">var</span> t = <span class="kw">new</span> Transcoder&lt;&lt;SimpleReader&lt;InputStream&gt;, CompactBinaryWriter&lt;OutputStream&gt;&gt;(schema);</code></pre></div>
<p>The <code>Transcoder</code> constructor is non-trivial so application usually should create an instance of <code>Transcoder</code> outside of the inner loop and reuse it.</p>
<p>The <code>Transcoder</code> class exposes one public method <code>Transcode</code> which takes two arguments, protocol reader representing payload to transcode from, and protocol writer to be used to write the result.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">t.<span class="fu">Transcode</span>(reader, writer);</code></pre></div>
<p>Bond provides a static helper API for application that don’t need to explicitly manage <code>Transcoder</code> lifetime and don’t specify payload schema or use a schema known at compile-time:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">// transcoding w/o schema</span>
Transcode.<span class="fu">FromTo</span>(reader, writer);

<span class="co">// transcoding with compile-time schema Foo</span>
Transcode&lt;Foo&gt;.<span class="fu">FromTo</span>(reader, writer);</code></pre></div>
<p>When an application calls this API for the first time, a static instance of appropriate <code>Transcoder</code> is created. Because of this the first call to the API for given type/schema and protocol may take relatively long time. Subsequent calls for the same reader/writer types reuse the static instance. Note that the static API can’t be used if source protocol is untagged and will result in runtime exception.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/protocol_transcoding</code></li>
</ul>
<h1 id="input-and-output-streams">Input and output streams</h1>
<p>The input and output for binary protocols is provided by the <a href="https://github.com/microsoft/bond/blob/master/cs/src/core/io/IInputStream.cs"><code>IInputStream</code></a> and <a href="https://github.com/microsoft/bond/blob/master/cs/src/core/io/IOutputStream.cs"><code>IOutputStream</code></a> interfaces. Bond comes with standard implementations of these interfaces for memory buffers and <code>System.IO.Stream</code>. Applications can also provide their own custom implementations.</p>
<p>The <code>OutputBuffer</code> class implements the <code>IOutputStream</code> interface on top of a memory buffer. It comes in two variants. <a href="https://github.com/microsoft/bond/blob/master/cs/src/core/io/safe/OutputBuffer.cs"><code>Bond.IO.Safe.OutputBuffer</code></a> uses only safe managed code and is included in the <code>Bond.dll</code> assembly. <a href="https://github.com/microsoft/bond/blob/master/cs/src/io/unsafe/OutputBuffer.cs"><code>Bond.IO.Unsafe.OutputBuffer</code></a> uses unsafe code to optimize for performance. It is included in the <code>Bond.IO.dll</code> assembly. Both implementations have identical class names and APIs; the only difference is the namespace in which they are defined.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">// Create an output buffer with initial size of 16KB</span>
<span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>(<span class="dv">16</span> * <span class="dv">1024</span>);
<span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

Serialize.<span class="fu">To</span>(writer, obj);

<span class="co">// Get the serialized payload form the output buffer</span>
ArraySegment&lt;<span class="dt">byte</span>&gt; data = output.<span class="fu">Data</span>;</code></pre></div>
<p>The <a href="https://github.com/microsoft/bond/blob/master/cs/src/core/io/safe/InputBuffer.cs"><code>InputBuffer</code></a> class implements the <code>IInputStream</code> interface on top of a memory buffer. Like <code>OutputBuffer</code> it comes in two flavors, the safe and portable <a href="https://github.com/microsoft/bond/blob/master/cs/src/core/io/safe/InputBuffer.cs"><code>Bond.IO.Safe.InputBuffer</code></a>, and the performance optimized via use of unsafe code <a href="https://github.com/microsoft/bond/blob/master/cs/src/io/unsafe/InputBuffer.cs"><code>Bond.IO.Unsafe.InputBuffer</code></a>.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">// Create an input buffer on top of a byte[]</span>
<span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(byteArray);
<span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputBuffer&gt;(input);</code></pre></div>
<p>The <a href="https://github.com/microsoft/bond/blob/master/cs/src/io/unsafe/InputStream.cs"><code>InputStream</code></a> and <a href="https://github.com/microsoft/bond/blob/master/cs/src/io/unsafe/OutputStream.cs"><code>OutputStream</code></a> classes provide implementations of <code>IInputStream</code> and <code>IOutputStream</code> on top of <code>System.IO.Stream</code>. These classes are included in <code>Bond.IO.dll</code> and thus are only available to applications using a full .NET runtime and allowing unsafe code. <code>In/OutputStream</code> can be used with any <code>Stream</code>, including <code>MemoryStream</code>. However <code>InputBuffer</code> and <code>OutputBuffer</code> provide significantly better performance and are recommended when working with in-memory payloads.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">using</span> (<span class="dt">var</span> stream = <span class="kw">new</span> <span class="fu">FileStream</span>(<span class="st">&quot;example.bin&quot;</span>, FileMode.<span class="fu">Open</span>))
{
    <span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputStream</span>(stream);
    <span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputStream&gt;(input);
    <span class="dt">var</span> example = Deserialize&lt;Example&gt;.<span class="fu">From</span>(reader);
}</code></pre></div>
<h1 id="cloner">Cloner</h1>
<p>The <code>Cloner</code> class provides API for deep cloning of objects representing Bond schemas. Unlike typical cloning, Bond <code>Cloner</code> is not limited to making clones that are of the same type as the source object. The type of the source and the clone merely need to represent compatible Bond schemas.</p>
<p>The <code>Cloner</code> is a generic class parameterized with the source type and its constructor takes one argument representing the type of clones to be created e.g.:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> cloner = <span class="kw">new</span> Cloner&lt;Foo&gt;(<span class="kw">typeof</span>(Bar));</code></pre></div>
<p>The constructor is non-trivial so application usually should create an instance of <code>Cloner</code> outside of the inner loop and reuse it.</p>
<p>The <code>Cloner</code> exposes one public, generic method <code>Clone</code> which takes as the argument the source object and returns a clone:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> clone = cloner.<span class="fu">Clone</span>&lt;Bar&gt;(foo);</code></pre></div>
<p>The object created by <code>Clone</code> is always of the type specified during <code>Cloner</code> construction. The type parameter of the method is only used to cast the result.</p>
<p>Bond provides a helper static API which creates and caches appropriate instance of <code>Cloner</code> the first time it is used, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> foo = <span class="kw">new</span> <span class="fu">Foo</span>();
<span class="dt">var</span> clone = Clone&lt;Bar&gt;.<span class="fu">From</span>(foo);</code></pre></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/cloning</code></li>
</ul>
<h1 id="comparer">Comparer</h1>
<p>The <code>Comparer</code> class provides API for deep comparison for equality of objects representing Bond schemas. The class exposes one public, static, generic method <code>Equal</code> which takes two parameters representing objects to be compared.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> left = <span class="kw">new</span> <span class="fu">Foo</span>();
<span class="dt">var</span> right = <span class="kw">new</span> <span class="fu">Foo</span>();

<span class="dt">bool</span> equal = Comparer.<span class="fu">Equal</span>(left, right);</code></pre></div>
<p>Note that the <code>Comparer</code> doesn’t compare arbitrary C# objects, it compares instances of Bond schemas. Only fields/properties decorated with Bond <a href="#idattribute">attributes</a> and base classes/interface representing Bond <a href="#schemaattribute">schemas</a> are considered during comparison.</p>
<h1 id="performance">Performance</h1>
<p>Bond offers very fast serialization and deserialization. Here are some tips on how to achieve the best performance.</p>
<ol style="list-style-type: decimal">
<li><p>Explicitly create instances of <code>Serializer</code>/<code>Deserializer</code>/<code>Transcoder</code></p>
<p>Instead of using simplified APIs like <code>Serialize.To</code> and <code>Deserialize&lt;T&gt;.From</code> it is usually better to explicitly instantiate and cache appropriate <code>Serializer</code>/<code>Deserializer</code>/<code>Transcoder</code> objects. Creation of these objects involves generation and JIT’ing of specific code to handle the particular operation for a given schema type and protocol(s). This may take a relatively long time, especially for large schemas, and usually it is best to do it during program initialization. Once the object is created it can be reused repeatedly and calling the Serialize/Deserialize/Transcode methods will be very fast.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> exampleSerializer = <span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;(<span class="kw">typeof</span>(Example));
<span class="dt">var</span> exampleDeserializer = <span class="kw">new</span> Deserializer&lt;CompactBinaryReader&lt;InputBuffer&gt;&gt;(<span class="kw">typeof</span>(Example));

<span class="dt">var</span> output = <span class="kw">new</span> <span class="fu">OutputBuffer</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> CompactBinaryWriter&lt;OutputBuffer&gt;(output);

exampleSerializer.<span class="fu">Serialize</span>(src, writer);

<span class="dt">var</span> input = <span class="kw">new</span> <span class="fu">InputBuffer</span>(output.<span class="fu">Data</span>);
<span class="dt">var</span> reader = <span class="kw">new</span> CompactBinaryReader&lt;InputBuffer&gt;(input);

<span class="dt">var</span> dst = exampleDeserializer.<span class="fu">Deserialize</span>&lt;Example&gt;(reader);</code></pre></div>
<p>Note that the type of <code>Serializer</code>/<code>Deserializer</code> doesn’t depend on the schema type so it is easy to cache these objects for multiple schemas used in an application:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> serializerCache = <span class="kw">new</span> Dictionary&lt;Type, Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;&gt;
    {
        {
            <span class="kw">typeof</span>(Foo),
            <span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;(<span class="kw">typeof</span>(Foo))
        },
        {
            <span class="kw">typeof</span>(Bar),
            <span class="kw">new</span> Serializer&lt;CompactBinaryWriter&lt;OutputBuffer&gt;&gt;(<span class="kw">typeof</span>(Bar))
        }
    };</code></pre></div></li>
<li><p>Prefer <code>InputBuffer</code> and <code>OutputBuffer</code> over <code>MemoryStream</code></p>
<p>When working with Bond payloads in a memory buffer (<code>byte[]</code> or <code>ArraySegment&lt;byte&gt;</code>) Bond-defined <code>InputBuffer</code> and <code>OutputBuffer</code> classes will provide significantly better performance than <code>InputStream</code> and <code>OutputStream</code> used together with <code>System.MemoryStream</code>.</p>
<p><code>OutputBuffer</code> by default preallocates 64 KB of memory. When serializing small objects the cost of allocating and zeroing the memory may dominate the actual cost of serialization. Conversely, when serializing very large objects the initial buffer of 64KB may be too small, leading to unnecessary reallocations and memory copying.</p>
<p>The <code>OutputBuffer</code> constructor accepts an argument specifying the size of initial buffer in bytes. For optimal performance the size should be set to be a little bigger than expect size of serialized data.</p></li>
<li><p>Prefer <code>using Bond.IO.Unsafe;</code> over <code>using Bond.IO.Safe;</code></p>
<p>Bond defines two variants of <code>InputBuffer</code> and <code>OutputBuffer</code> in two namespaces <code>Bond.IO.Safe</code> and <code>Bond.IO.Unsafe</code>. The classes have identical interface and can be used interchangeably. The only difference is that the latter uses some low level memory access constructs and is implemented in <code>Bond.IO.dll</code> assembly which is compiled with <code>/unsafe</code> flag. The unsafe version is faster.</p></li>
<li><p>Pool memory buffers</p>
<p>Creating a new <code>InputBuffer</code>/<code>OutputBuffer</code> every time may be more costly than the actual serialization or deserialization and it increases GC pressure. Whenever possible pool and reuse buffers, simply resetting their position after or before use:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">buffer.<span class="fu">Position</span> = <span class="dv">0</span>;</code></pre></div></li>
<li><p>Choose the right protocol</p>
<p>The Fast Binary protocol is a little faster than Compact Binary, although the difference is not big. Untagged protocols like Simple Binary can provide much better performance (up to 4 times faster for some schemas). They are most applicable in scenarios where runtime schema of the data is available during deserialization and the same schema applies to many instances of the data, so that the cost of creating the <a href="#deserializer"><code>Deserializer</code></a> can be amortized. The canonical use case for an untagged protocol is record-based data storage.</p></li>
<li><p>Experiment with <code>inlineNested</code> when creating <code>Serializer</code>/<code>Deserializer</code>/<code>Transcoder</code> instances</p>
<p>When a <code>Serializer</code>/<code>Deserializer</code>/<code>Transcoder</code> refers to another Bond struct, by default, the instructions to serialize/deserialize/transcode that type are inlined in the method for the top-level type. This <em>often</em> results in better runtime performance. However, it can sometimes cause long JIT’ing times when creating <code>Serializer</code>/<code>Deserializer</code>/<code>Transcoder</code> instances or worse runtime performance. (For example, some optimizations are not performed when methods get large.) You will need to profile and experiment with instances created with <code>inlineNested</code> set to <code>true</code> (the default) and <code>false</code>) to see what is the best fit for your scenario.</p></li>
</ol>
<h1 id="runtime-schema">Runtime schema</h1>
<p>Some generic applications may need to work with Bond schemas unknown at compile-time. In order to address such scenarios Bond defines a type <code>SchemaDef</code> to represent schemas at runtime. Applications can obtain an instance of <code>SchemaDef</code> for a particular type using the <code>Schema</code> class:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">// from a type T</span>
<span class="dt">var</span> schema = Schema&lt;T&gt;.<span class="fu">RuntimeSchema</span>;

<span class="co">// from type of an object</span>
<span class="dt">var</span> schema = Schema.<span class="fu">GetRuntimeSchema</span>(<span class="kw">typeof</span>(obj));</code></pre></div>
<p>The APIs return an object of type <code>RuntimeSchema</code>, which is a thin wrapper over <code>SchemaDef</code>. Access to underlying schema is provided via public properties:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> schemaDef = schema.<span class="fu">SchemaDef</span></code></pre></div>
<p>The <code>SchemaDef</code> object is always self contained, including the runtime schema definitions for all nested types (if any). The <code>RuntimeSchema</code> class instance can be constructed from a <code>SchemaDef</code>, and then it represents the whole schema, or from any embedded <code>TypeDef</code>:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">// runtime schema of Foo</span>
<span class="dt">var</span> schema = Schema&lt;Foo&gt;.<span class="fu">RuntimeSchema</span>;

<span class="co">// runtime schema of the first field of Foo</span>
<span class="dt">var</span> fieldSchema = <span class="kw">new</span> <span class="fu">RuntimeSchema</span>(schema, schema.<span class="fu">StructDef</span>.<span class="fu">fields</span>[<span class="dv">0</span>].<span class="fu">type</span>);</code></pre></div>
<p><code>SchemaDef</code> is a Bond type, defined in <code>bond.bond</code>, and as such can be de/serialized like any other Bond type:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">Serialize.<span class="fu">To</span>(writer, Schema&lt;T&gt;.<span class="fu">RuntimeSchema</span>.<span class="fu">SchemaDef</span>);</code></pre></div>
<p>A serialized representation of <code>SchemaDef</code> can be also obtained directly from a schema definition IDL file using <a href="compiler.html#runtime-schema">bond compiler</a>.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/runtime_schema</code></li>
</ul>
<h1 id="understanding-bondedt">Understanding <code>bonded&lt;T&gt;</code></h1>
<p>The generic type <code>bonded&lt;T&gt;</code> is a simple yet powerful abstraction which is a fundamental part of Bond APIs and enables such usage scenarios as lazy deserialization, pass-through and polymorphism.</p>
<p>In C# <code>bonded&lt;T&gt;</code> maps to <code>IBonded&lt;T&gt;</code> interface which supports three operations: <code>Serialize</code>, <code>Deserialize</code> and <code>Convert</code>. Bond provides two standard implementation of the <code>IBonded&lt;T&gt;</code> interface, <code>Bonded&lt;T&gt;</code> which can hold and instance of type <code>T</code>, and <code>Bonded&lt;T, R&gt;</code> which can hold a serialized payload represented by a protocol reader <code>R</code>. The former is usually used by producers to initialize <code>bonded&lt;T&gt;</code> values, the latter is implicitly used during deserialization.</p>
<p>The standard implementations always use default implementations of <code>Serializer/Deserializer/Cloner/Transcoder</code>. In order to customize this behavior, the user can pass custom <code>ObjectBondedFactory</code> or <code>PayloadBondedFactory</code> delegates as parameters to <code>ObjectParser</code> or <code>ParserFactory&lt;R&gt;.Create()</code>:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">// create serializer for schema type T and protocol reader W</span>
<span class="co">// using custom InstanceBondedFactory</span>
<span class="kw">new</span> Serializer&lt;W&gt;(<span class="kw">typeof</span>(T), <span class="kw">new</span> <span class="fu">ObjectParser</span>(<span class="kw">typeof</span>(T), CustomObjectBondedFactory), ...);

<span class="co">// create deserializer for schema type T and protocol reader R</span>
<span class="co">// using custom PayloadBondedFactory</span>
<span class="kw">new</span> Deserializer&lt;R&gt;(<span class="kw">typeof</span>(T), ParserFactory&lt;R&gt;.<span class="fu">Create</span>(<span class="kw">typeof</span>(T), CustomPayloadBondedFactory), ...);</code></pre></div>
<h2 id="lazy-deserialization">Lazy deserialization</h2>
<p>Because <code>bonded&lt;T&gt;</code> can store (or more accurately, refer to) data representing a serialized data, it can be used to de facto delay deserialization of some parts of payload:</p>
<pre><code>struct Example
{
    0: Always always;
    1: bonded&lt;Sometimes&gt; sometimes;
}</code></pre>
<p>The schema defined above contains two nested fields. When an object of type <code>Example</code> is deserialized, the field <code>always</code> will be fully instantiated and deserialized, but field <code>sometimes</code>, which is declared as <code>bonded&lt;Sometimes&gt;</code>, will be merely initialized with a reference to its serialized representation. Application can then deserialize the object only when needed:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> example = Deserialize&lt;Example&gt;.<span class="fu">From</span>(reader);

<span class="co">// Deserialize sometimes only when needed</span>
<span class="kw">if</span> (needSometimes)
{
    <span class="dt">var</span> sometimes = example.<span class="fu">sometimes</span>.<span class="fu">Deserialize</span>();
}</code></pre></div>
<h2 id="pass-through">Pass-through</h2>
<p>When <code>bonded&lt;T&gt;</code> containing a payload is serialized all the field from the original payload are preserved. This property very useful when building multi-stage service pipelines. Intermediary nodes often need to pass data through with full fidelity. At the same time, it is desirable that every schema change doesn’t necessitate redeployment of all the nodes in a pipeline. Using <code>bonded&lt;T&gt;</code> for pass-through is often the right solution.</p>
<p>As an example let’s imagine a simple aggregator which receives responses from upstream services and aggregates top results.</p>
<pre><code>struct Upstream
{
    0: bonded&lt;Response&gt; response;
    1: float ranking;
}

struct Aggregated
{
    0: list&lt;bonded&lt;Response&gt;&gt; responses;
}</code></pre>
<p>Using <code>bonded&lt;Response&gt;</code> allows the intermediary to aggregate responses, preserving their full content, even if the aggregator doesn’t use the same version of the <code>Response</code> schema as the upstream.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">void</span> <span class="fu">ProcessResponse</span>(Upstream upstream)
{
    <span class="kw">if</span> (upstream.<span class="fu">ranking</span> &gt; threshold)
    {
        aggregated.<span class="fu">responses</span>.<span class="fu">Add</span>(upstream.<span class="fu">response</span>);
    }
}</code></pre></div>
<h2 id="polymorphism">Polymorphism</h2>
<p>The type parameter <code>T</code> in <code>IBonded&lt;T&gt;</code> interface is covariant which enables polymorphism. A <code>IBonded&lt;Base&gt;</code> can be initialized with an instance of <code>Bonded&lt;Derived&gt;</code>. For example, given the following schema:</p>
<pre><code>enum Kind
{
    rectangle,
    circle,
    none
}

struct Shape
{
    0: Kind kind = none;
}

struct Rectangle: Shape
{
    0: int32 width;
    1: int32 height;
}

struct Circle : Shape
{
    0: int32 radius;
}

struct Example
{
    0: vector&lt;bonded&lt;Shape&gt;&gt; shapes;
}</code></pre>
<p>The type of the <code>shapes</code> field in C# class <code>Example</code> will be <code>List&lt;IBonded&lt;Shape&gt;&gt;</code> and an instance of the <code>Example</code> can be initialized as following:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> src = <span class="kw">new</span> Example
{
    shapes =
    {
        <span class="kw">new</span> Bonded&lt;Circle&gt;(<span class="kw">new</span> Circle {kind = Kind.<span class="fu">circle</span>, radius = <span class="dv">10</span>),
        <span class="kw">new</span> Bonded&lt;Rectangle&gt;(<span class="kw">new</span> Rectangle {kind = Kind.<span class="fu">rectangle</span>, width = <span class="dv">4</span>, height = <span class="dv">5</span>)
    }
};</code></pre></div>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/polymorphic_container</code></li>
</ul>
<h1 id="custom-type-mappings">Custom type mappings</h1>
<p>Bond codegen provides a simple extensibility mechanism allowing use of custom C# types to represent types in a Bond schema. One common scenario is replacing the default collections with a different implementation that is semantically identical, e.g. <code>SortedSet&lt;T&gt;</code> instead of <code>HashSet&lt;T&gt;</code>. Custom type mappings can be also used to introduce completely new types which can be serialized as one of the built-in Bond schema types. For example time could be represented using the <code>DateTime</code> class and serialized as <code>int64</code>.</p>
<p>Defining a custom type mapping involves three steps:</p>
<ul>
<li>Define a <a href="compiler.html#type-aliases">type alias</a> in the schema.</li>
<li>Specify during codegen a C# type to represent the alias.</li>
<li>Implement an appropriate converter for the custom C# type.</li>
</ul>
<h2 id="codegen-parameters">Codegen parameters</h2>
<p>When generating code for a schema that uses <a href="compiler.html#type-aliases">type aliases</a>, the user can specify a custom type to represent each alias in the generated code:</p>
<pre><code>gbc c# --using=&quot;DateTime=System.DateTime&quot; date_time.bond</code></pre>
<p>The value of the <code>/using</code> parameter consists of one or more alias substitutions separated by semicolons, each in the following format:</p>
<pre><code>alias-name=generated-type-name</code></pre>
<h2 id="custom-containers">Custom containers</h2>
<p>Type aliases of container types can be mapped to user defined collection classes as long as they implement the same interfaces as the default collections: <code>IEnumerable&lt;T&gt;</code> as well as <code>ICollection&lt;T&gt;</code> for aliases of <code>list&lt;T&gt;</code> and <code>vector&lt;T&gt;</code>, <code>ISet&lt;T&gt;</code> for aliases of <code>set&lt;T&gt;</code> and <code>IDictionary&lt;K, V&gt;</code> for aliases of <code>map&lt;K ,V&gt;</code>. Custom mappings of container type aliases don’t require a user defined converter.</p>
<ul>
<li><code>examples/cs/core/container_alias</code></li>
</ul>
<h2 id="system.collection.immutable-support">System.Collection.Immutable support</h2>
<p>Bond provides special support for using the <a href="https://learn.microsoft.com/dotnet/api/system.collections.immutable">System.Collections.Immutable</a> collections as container type aliases. The following aliases are supported:</p>
<table>
<colgroup>
<col width="20%" />
<col width="79%" />
</colgroup>
<thead>
<tr class="header">
<th>Underlying Bond type</th>
<th>Supported System.Collections.Immutable container</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>vector&lt;T&gt;</code></td>
<td><code>ImmutableArray&lt;T&gt;</code>, <code>ImmutableList&lt;T&gt;</code></td>
</tr>
<tr class="even">
<td><code>list&lt;T&gt;</code></td>
<td><code>ImmutableArray&lt;T&gt;</code>, <code>ImmutableHashSet&lt;T&gt;</code>, <code>ImmutableList&lt;T&gt;</code>, <code>ImmutableSortedSet&lt;T&gt;</code></td>
</tr>
<tr class="odd">
<td><code>set&lt;T&gt;</code></td>
<td><code>ImmutableHashSet&lt;T&gt;</code>, <code>ImmutableSortedSet&lt;T&gt;</code></td>
</tr>
<tr class="even">
<td><code>map&lt;K, V&gt;</code></td>
<td><code>ImmutableDictionary&lt;K, V&gt;</code>, <code>ImmutableSortedDictionary&lt;K, V&gt;</code></td>
</tr>
</tbody>
</table>
<p>During code generation, immutable collection fields are handled specially. Since they do not have parameterless constructors, the Bond compiler will instead use the static <code>Empty</code> field is used as the default value, e.g. <a href="https://learn.microsoft.com/dotnet/api/system.collections.immutable.immutablelist-1.empty">ImmutableList&lt;T&gt;.Empty</a>.</p>
<p>When deserializing immutable collections, Bond will use the inner <code>Builder</code> classes to efficiently reconstruct the collection, e.g. <a href="https://learn.microsoft.com/dotnet/api/system.collections.immutable.immutablelist-1.builder">ImmutableList&lt;T&gt;.Builder</a>.</p>
<p>See the below project for examples on using immutable collections as container aliases:</p>
<ul>
<li><code>examples/cs/core/immutable_collections_alias</code></li>
</ul>
<h2 id="converter">Converter</h2>
<p>Applications using custom mappings for aliases of scalar types, string or blob must provide converter between the custom type and the default type. The converter is a public class named <code>BondTypeAliasConverter</code> defining a pair of public static <code>Convert</code> methods for each type alias:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> CustomType <span class="fu">Convert</span>(AliasedType value, CustomType unused)
<span class="kw">public</span> <span class="kw">static</span> AliasedType <span class="fu">Convert</span>(CustomType value, AliasedType unused)</code></pre></div>
<p>For example if <code>System.DateTime</code> was mapped to an alias of <code>int64</code> the following class could be defined to provide conversions between <code>DateTime</code> and <code>long</code> (the default type for <code>int64</code>):</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">static</span> <span class="kw">class</span> BondTypeAliasConverter
{
    <span class="kw">public</span> <span class="kw">static</span> <span class="dt">long</span> <span class="fu">Convert</span>(DateTime value, <span class="dt">long</span> unused)
    {
        <span class="kw">return</span> value.<span class="fu">Ticks</span>;
    }

    <span class="kw">public</span> <span class="kw">static</span> DateTime <span class="fu">Convert</span>(<span class="dt">long</span> value, DateTime unused)
    {
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">DateTime</span>(value);
    }
}</code></pre></div>
<p>The converter class must be defined in the same assembly and namespace as the class representing the Bond schema(s) in which the type alias is used or assembly/namespace of one of the types being converted.</p>
<ul>
<li><code>examples/cs/core/date_time</code></li>
<li><code>examples/cs/core/decimal</code></li>
<li><code>examples/cs/core/guid</code></li>
</ul>
<h1 id="xml">Xml</h1>
<p>Bond supports Xml serialization via Simple Xml protocol implemented by the <code>SimpleXmlReader</code> and <code>SimpleXmlWriter</code> classes:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> stream = <span class="kw">new</span> System.<span class="fu">IO</span>.<span class="fu">MemoryStream</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> <span class="fu">SimpleXmlWriter</span>(stream);

Serialize.<span class="fu">To</span>(writer, src);

output.<span class="fu">Flush</span>();
stream.<span class="fu">Position</span> = <span class="dv">0</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleXmlReader</span>(stream);

<span class="dt">var</span> dst = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></div>
<p>In the example above the Xml reader and writer are constructed directly from an instance of <code>System.Stream</code>. Underneath however they use <code>System.Xml.XmlReader</code> and <code>System.Xml.XmlWriter</code> which provide fast, non-cached, forward-only Xml parsing and generation on top of many different data readers and writers. For example to deserialize Xml payload from a string:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">var xmlString = <span class="st">&quot;&lt;Record&gt;&lt;Name&gt;test&lt;/Name&gt;&lt;Numbers&gt;&lt;Item&gt;3.14&lt;/Item&gt;&lt;/Numbers&gt;&lt;/Record&gt;&quot;</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleXmlReader</span>(XmlReader.<span class="fu">Create</span>(<span class="kw">new</span> <span class="fu">StringReader</span>(xmlString)));
<span class="dt">var</span> record = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></div>
<p>The Simple Xml protocol flattens the inheritance hierarchy, putting fields from base and derived classes together under a single element. In order to prevent name conflicts, Simple Xml protocol provides support for optional use of fully qualified schema names as field element namespaces, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;Derived</span><span class="ot"> xmlns:b=</span><span class="st">&quot;urn:Examples.Base&quot;</span><span class="ot"> xmlns:d=</span><span class="st">&quot;urn:Examples.Derived&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;d:Field&gt;</span>10<span class="kw">&lt;/d:Field&gt;</span>
    <span class="kw">&lt;b:Field&gt;</span>foo<span class="kw">&lt;/b:Field&gt;</span>
<span class="kw">&lt;/Derived&gt;</span></code></pre></div>
<p>Namespaces can be enabled when serializing to Xml via the <code>UseNamespaces</code> flag in SimpleXmlWriter.Settings:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> writer = <span class="kw">new</span> <span class="fu">SimpleXmlWriter</span>(stream, <span class="kw">new</span> SimpleXmlWriter.<span class="fu">Settings</span>
{
    UseNamespaces = <span class="kw">true</span>
});</code></pre></div>
<p>There is no need to enable namespace support for the SimpleXmlReader. The elements representing fields are always matched against field names and their namespaces, if specified in the Xml document, against the qualified names of the containing structs.</p>
<p>Using Xml namespace inherently limits some of flexibility of Bond deserialization. In particular a document with namespaces can’t be deserialized into a schema that is compatible but has a different name, for example a <a href="compiler.html#struct-views">view</a> of the payload schema.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/simple_xml</code></li>
</ul>
<h1 id="json">JSON</h1>
<p>Bond supports JSON serialization via the Simple JSON protocol implemented by the <code>SimpleJsonReader</code> and <code>SimpleJsonWriter</code> classes. The JSON protocol depends on the Newtonsoft JSON parser and the classes are in a separate assembly <code>Bond.JSON.dll</code>.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> stream = <span class="kw">new</span> System.<span class="fu">IO</span>.<span class="fu">MemoryStream</span>();
<span class="dt">var</span> writer = <span class="kw">new</span> <span class="fu">SimpleJsonWriter</span>(stream);

Serialize.<span class="fu">To</span>(writer, src);

output.<span class="fu">Flush</span>();
stream.<span class="fu">Position</span> = <span class="dv">0</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleJsonReader</span>(stream);

<span class="dt">var</span> dst = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></div>
<p>In the example above the JSON reader and writer are constructed directly from an instance of <code>System.Stream</code>. Alternatively they can be also constructed from <code>System.IO.TextReader</code> and <code>System.IO.TextWriter</code>. For example to deserialize JSON payload from a string:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">var jsonString = <span class="st">&quot;{Name: test, Numbers: [3.14]}&quot;</span>;

<span class="dt">var</span> reader = <span class="kw">new</span> <span class="fu">SimpleJsonReader</span>(<span class="kw">new</span> <span class="fu">StringReader</span>(jsonString));
<span class="dt">var</span> record = Deserialize&lt;Record&gt;.<span class="fu">From</span>(reader);</code></pre></div>
<p>The Simple JSON protocol flattens the inheritance hierarchy, putting fields from base and derived schemas together in the same JSON object. Name conflicts in the JSON representation between fields of base and derived schema can be resolved using <code>JsonName</code> schema field attribute:</p>
<pre><code>struct Base
{
    0: string name;
}

struct Derived : Base
{
    [JsonName(&quot;DerivedName&quot;)]
    0: string name;
}</code></pre>
<p>See also the following example:</p>
<ul>
<li><code>examples/cs/core/simple_json</code></li>
</ul>
<h1 id="attributes">Attributes</h1>
<p>Bond defines several attributes which are used to decorate user defined types with extra information required by Bond.</p>
<h2 id="schema-decoration">Schema decoration</h2>
<p>User defined types that represent Bond schemas and their members are decorated with following attributes.</p>
<h3 id="schemaattribute">SchemaAttribute</h3>
<p>The <code>Schema</code> attribute is used to mark types that represent Bond schemas and thus can be used with Bond APIs. The attribute can be applied to classes, structs and interfaces.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo {}

[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">struct</span> Bar {}

[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">interface</span> IFoo {}</code></pre></div>
<p>The <code>Schema</code> attribute applies to the specific type only and is not inherited. When a class decorated with the <code>Schema</code> attribute derives from another class also decorated with the attribute then it represents Bond schema hierarchy. When a class representing schema derives from a class that is not marked with the <code>Schema</code> attribute then it represents a simple schema without a base, the C# base class is ignored by Bond.</p>
<p>When a C# class/interfaces representing a schema derives from multiple interfaces, at most one can be an interface representing a schema (i.e. decorated with <code>[Schema]</code> attribute).</p>
<h3 id="namespaceattribute">NamespaceAttribute</h3>
<p>The <code>Namespace</code> attribute can be optionally used to annotate C# classes, interfaces and enums if their C# namespace is different than the schema namespace (i.e. namespace in .bond idl file), for example when C# code is generated with <code>--namespace</code> flag.</p>
<p>Bond will use the <code>Namespace</code> attribute, when present, to create qualified name of the type. If the attribute is absent the qualified name will use the C# namespace in which the type is defined.</p>
<h3 id="idattribute">IdAttribute</h3>
<p>All public fields and properties that represents fields of a Bond schema must be decorated with the <code>Id</code> attribute to specify the field’s identifier (also called field ordinal). The ordinal value must an unsigned 16-bit integer, unique for each field within a type.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>)]
    <span class="kw">public</span> <span class="dt">string</span> message { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></div>
<p>A type representing a schema may have additional fields/properties that don’t represent schema fields and thus are not decorated with Bond attributes.</p>
<h3 id="requiredattribute">RequiredAttribute</h3>
<p>By default fields of Bond schemas are optional. <a href="bond_cpp.html#required-fields">Required fields</a> must be marked with the <code>Required</code> attribute.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="co">/* Bond schema</span>
<span class="co">struct Foo</span>
<span class="co">{</span>
<span class="co">    0: required string message;</span>
<span class="co">}</span>
<span class="co">*/</span>
[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), Bond.<span class="fu">Required</span>]
    <span class="kw">public</span> <span class="dt">string</span> message { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></div>
<h3 id="typeattribute">TypeAttribute</h3>
<p>The <code>Type</code> attribute is used to provide additional type information about schema fields. The attribute is optional because in most cases Bond can infer type from the C# type of field/property. For example C# type <code>short</code> always maps to Bond type <code>int16</code>. However not all C# types have an unambiguous mapping to Bond type system. For example C# <code>string</code> can represent either Bond type <code>string</code> or <code>wstring</code>. Similarly C# reference types which are always <em>nullable</em> can represent both <em>nullable</em> and <em>non-nullable</em> type in Bond schema. One of the uses for the <code>Type</code> is resolving such ambiguities.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">using</span> Bond.<span class="fu">Tag</span>;

<span class="co">/* Bond schema</span>
<span class="co">struct Foo</span>
<span class="co">{</span>
<span class="co">    0: nullable&lt;wstring&gt; str1;</span>
<span class="co">    1: string str2 = nothing;</span>
<span class="co">}</span>
<span class="co">*/</span>
[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), Bond.<span class="fu">Type</span>(<span class="kw">typeof</span>(nullable&lt;wstring&gt;))]
    <span class="kw">public</span> <span class="dt">string</span> str1 = <span class="kw">null</span>;

    [Bond.<span class="fu">Id</span>(<span class="dv">1</span>)]
    <span class="kw">public</span> <span class="dt">string</span> str2 = <span class="kw">null</span>;
}</code></pre></div>
<p>Bond defines the following tag types that can be used in a <code>Type</code> attribute:</p>
<ul>
<li><code>nullable</code>: specifies that a reference or nullable C# type represents a <em>nullable</em> type in the Bond type system.</li>
<li><code>wstring</code>: specifies that a string is UTF16 (i.e. <code>wstring</code> in the Bond type system).</li>
<li><code>blob</code>: specifies that the type represents the schema type <code>blob</code>.</li>
</ul>
<p>The <code>Type</code> attribute can also be used to specify type of object to be created during deserialization when a field/property type is an interface.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), Bond.<span class="fu">Type</span>(<span class="kw">typeof</span>(SortedSet&lt;<span class="dt">string</span>&gt;))]
    <span class="kw">public</span> ISet&lt;<span class="dt">string</span>&gt; strings1 { <span class="kw">get</span>; <span class="kw">set</span>; }

    [Bond.<span class="fu">Id</span>(<span class="dv">1</span>), Bond.<span class="fu">Type</span>(<span class="kw">typeof</span>(HashSet&lt;<span class="dt">string</span>&gt;))]
    <span class="kw">public</span> ISet&lt;<span class="dt">string</span>&gt; strings2 { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></div>
<h3 id="defaultattribute">DefaultAttribute</h3>
<p>Bond infers default field values for classes and structs representing schemas from the field initializers or the class/struct constructor. For interfaces the default field values must be specified explicitly by decorating the interface properties with the <code>Default</code> attribute. The value specified in the attribute must be compatible with the field type, otherwise the behaviour is undefined.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
<span class="kw">public</span> <span class="kw">interface</span> IFoo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), <span class="fu">Default</span>(<span class="st">&quot;default value&quot;</span>)]
    <span class="kw">public</span> <span class="dt">string</span> { <span class="kw">get</span>; <span class="kw">set</span>; }

    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>), <span class="fu">Default</span>(<span class="fl">3.</span>14f)]
    <span class="kw">public</span> <span class="dt">float</span> { <span class="kw">get</span>; <span class="kw">set</span>; }
}</code></pre></div>
<p>The <code>Default</code> attribute is optional for properties that are decorated with <code>nullable</code> tag (the default is implicitly <code>null</code>). For non-nullable collections the <code>Default</code> attribute can either specify <code>null</code>, which means default of <code>nothing</code> in the schema, or it can be omitted, which means the default is an empty collection. Non-nullable properties of a type representing a schema have no concept of a default value thus the <code>Default</code> attribute is not applicable.</p>
<h3 id="attributeattribute">AttributeAttribute</h3>
<p>The <code>Attribute</code> attribute can be used to specify user defined attribute(s) for schemas, fields and enums.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Schema</span>]
[Bond.<span class="fu">Attribute</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;value&quot;</span>)]
<span class="kw">public</span> <span class="kw">class</span> Foo
{
    [Bond.<span class="fu">Id</span>(<span class="dv">0</span>)]
    [Bond.<span class="fu">Attribute</span>(<span class="st">&quot;custom1&quot;</span>, <span class="st">&quot;value1&quot;</span>)]
    [Bond.<span class="fu">Attribute</span>(<span class="st">&quot;custom2&quot;</span>, <span class="st">&quot;value2&quot;</span>)]
    <span class="kw">public</span> <span class="dt">string</span> foo;
}</code></pre></div>
<p>Schema attributes are usually used by transforms to customize code generation but they can also be accessed by applications via reflection.</p>
<h2 id="protocol-decoration">Protocol decoration</h2>
<p>Bond defines several attributes that are used to decorate implementation of custom protocols with extra information.</p>
<h3 id="readerattribute">ReaderAttribute</h3>
<p>The <code>Reader</code> attribute is used on a protocol writer implementation and specifies the type that implements the reader for that protocol.</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Reader</span>(<span class="kw">typeof</span>(SimpleXmlReader))]
<span class="kw">public</span> <span class="kw">struct</span> SimpleXmlWriter : IProtocolWriter
{
    <span class="co">// ...</span>
}</code></pre></div>
<h3 id="parserattribute">ParserAttribute</h3>
<p>The <code>Parser</code> attribute can be used on a protocol reader implementation and specifies the type of parser to be used for the protocol. It is optional for protocols that implement <code>IUntaggedReader</code> or <code>ITaggedReader</code> because they implicitly default to use <code>UntaggedParser</code> and <code>TaggedParser</code> respectively. When specified, the <code>Parser</code> attribute value must be a generic type definition with one type parameter, it must implement <code>IParser</code> interface and have two public constructors, one accepting <code>RuntimeSchema</code> argument and one accepting <code>Type</code> argument (compile-time schema).</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Parser</span>(<span class="kw">typeof</span>(SimpleXmlParser&lt;&gt;))]
<span class="kw">public</span> <span class="kw">struct</span> SimpleXmlReader : IXmlReader
{
    <span class="co">// ...</span>
}

<span class="kw">public</span> <span class="kw">class</span> SimpleXmlParser&lt;R&gt; : IParser
{
    <span class="fu">SimpleXmlParser</span>(RuntimeSchema schema)
    {
        <span class="co">// ...</span>
    }

    <span class="fu">SimpleXmlParser</span>(Type schema)
    {
        <span class="co">// ...</span>
    }
}</code></pre></div>
<h3 id="serializerattribute">SerializerAttribute</h3>
<p>The <code>Serializer</code> attribute can be used on a protocol writer implementation to specify custom serializer for the writer. If the attribute is not specified then the default serializer implementation is used. The value of <code>Serializer</code> attribute must be a generic type definition with two type parameters <code>R</code> and <code>W</code>, it must implement <code>ISerializerGenerator&lt;R, W&gt;</code> interface and define two public constructors:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs">[Bond.<span class="fu">Serializer</span>(<span class="kw">typeof</span>(CustomSerializer&lt;,&gt;))]
<span class="kw">public</span> <span class="kw">struct</span> SimpleXmlWriter : IProtocolWriter
{
    <span class="co">// ...</span>
}

<span class="kw">public</span> <span class="kw">class</span> CustomSerializer&lt;R, W&gt; : ISerializerGenerator&lt;R, W&gt;
{
    <span class="kw">public</span> <span class="fu">CustomSerializer</span>(Expression&lt;Action&lt;R, W, <span class="dt">int</span>&gt;&gt; deferredSerialize, RuntimeSchema schema)
    {
        <span class="co">// ...</span>
    }

    <span class="kw">public</span> <span class="fu">CustomSerializer</span>(Expression&lt;Action&lt;R, W, <span class="dt">int</span>&gt;&gt; deferredSerialize, Type type)
    {
        <span class="co">// ...</span>
    }
}</code></pre></div>
<h1 id="nuget-packages">NuGet packages</h1>
<p>Pre-compiled versions of Bond are distributed via NuGet packages from NuGet.org.</p>
<p><a href="https://www.nuget.org/packages/Bond.CSharp/"><img src="https://img.shields.io/nuget/v/Bond.CSharp.svg?style=flat" alt="Bond.CSharp NuGet package" /></a> <strong>Bond.CSharp</strong> - An omnibus package that pulls in everything required to use Bond in a C# project. If you’re not sure which packages to use, use this one. (It will pull in all the other packages you need.)</p>
<p><a href="https://www.nuget.org/packages/Bond.Core.CSharp/"><img src="https://img.shields.io/nuget/v/Bond.Core.CSharp.svg?style=flat" alt="Bond.Core.CSharp NuGet package" /></a> <strong>Bond.Core.CSharp</strong> - The assemblies required to use Bond at runtime. Useful if some other assembly already contains the compiled types. If your project contains .bond files, you will need to use either Bond.CSharp or Bond.Compiler.CSharp to perform code generation at build time.</p>
<p><a href="https://www.nuget.org/packages/Bond.Runtime.CSharp/"><img src="https://img.shields.io/nuget/v/Bond.Runtime.CSharp.svg?style=flat" alt="Bond.Runtime.CSharp NuGet package" /></a> <strong>Bond.Runtime.CSharp</strong> - Additional assemblies that may be needed at runtime depending on which Bond <a href="bond_cpp.html#protocols">protocols</a> are being used. Needed for Simple JSON.</p>
<p><a href="https://www.nuget.org/packages/Bond.Compiler.CSharp/"><img src="https://img.shields.io/nuget/v/Bond.Compiler.CSharp.svg?style=flat" alt="Bond.Compiler.CSharp NuGet package" /></a> <strong>Bond.Compiler.CSharp</strong> - A package with the <a href="compiler.html">Bond compiler (gbc)</a> and MSBuild targets for C# code generation. Bond.CSharp includes similar functionality, but pulls in lots of dependencies. Bond.Complier.CSharp has no dependencies.</p>
<p><a href="https://www.nuget.org/packages/Bond.Compiler/"><img src="https://img.shields.io/nuget/v/Bond.Compiler.svg?style=flat" alt="Bond.Compiler NuGet package" /></a> <strong>Bond.Compiler</strong> - A tools-only package that contains the <a href="compiler.html">Bond compiler (gbc)</a>. This is useful if you want to integrate gbc into a build process that isn’t using C# or MSBuild.</p>
<p>For example, if you want to use Bond’s Compact Binary protocol but want to avoid a dependency on Newtonsoft’s JSON.NET, you can use the Bond.Compiler.CSharp and Bond.Core.CSharp packages together.</p>
<h2 id="platform-limitations">Platform limitations</h2>
<p>The pre-compiled gbc that is included in these packages is Windows-only. See the <a href="https://github.com/microsoft/bond/blob/master/README.md">README</a> for instructions to build gbc for other platforms.</p>
<p>Bond.IO.dll (which provides the types in the Bond.IO.Unsafe namespace) is currently Windows-only, as it relies on some Win32 APIs. To stay cross-platform, only use the types from Bond.dll (in the Bond.IO.Safe namespace).</p>
<h2 id="frameworks-targeted">Frameworks targeted</h2>
<p>This table lists which frameworks are targeted by the Bond assemblies.</p>
<p>This table is accurate for Bond NuGet packages 11.0 and later.</p>
<table style="width:100%;">
<colgroup>
<col width="24%" />
<col width="9%" />
<col width="11%" />
<col width="18%" />
<col width="18%" />
<col width="18%" />
</colgroup>
<thead>
<tr class="header">
<th>Assembly</th>
<th>.NET 4.5</th>
<th>.NET 4.6.2</th>
<th>.NET Standard 1.0</th>
<th>.NET Standard 1.3</th>
<th>.NET Standard 1.6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bond.Attributes.dll</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>←</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Bond.Reflection.dll</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>←</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Bond.dll</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>←</td>
<td>Yes</td>
</tr>
<tr class="even">
<td>Bond.JSON.dll</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>←</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td>Bond.IO.dll</td>
<td>No</td>
<td>Win only</td>
<td>No</td>
<td>Win only</td>
<td>Win only</td>
</tr>
</tbody>
</table>
<p>A left arrow (←) indicates that support for that framework is provided by the version of the assembly that targets a lower version of the framework.</p>
<h1 id="references">References</h1>
<h2 id="bond-compiler-referencecompiler"><a href="compiler.html">Bond compiler reference</a></h2>
<h2 id="c-users-manualbond_cpp"><a href="bond_cpp.html">C++ User’s Manual</a></h2>
<h2 id="python-users-manualbond_py"><a href="bond_py.html">Python User’s Manual</a></h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In Bond there is no concept of a default value for structs and thus a default of <code>nothing</code> can’t be set for fields of struct types or <code>bonded&lt;T&gt;</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Some protocols might not support omitting optional fields (e.g. Simple Protocol). In such cases an attempt to serialize an object with field(s) set to <code>nothing</code> will result in a runtime exception.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
</div>
</div>
</body>
</html>
